{"ast":null,"code":"export const createOffer = async (connection, localStream, userToCall, doOffer, database, username) => {\n  try {\n    connection.addStream(localStream);\n    const offer = await connection.createOffer();\n    await connection.setLocalDescription(offer);\n    doOffer(userToCall, offer, database, username);\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const initiateLocalStream = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    });\n    return stream;\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const initiateConnection = async () => {\n  try {\n    // using Google public stun server\n    var configuration = {\n      iceServers: [{\n        urls: 'stun:stun2.1.google.com:19302'\n      }]\n    };\n    const conn = new RTCPeerConnection(configuration);\n    return conn;\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const sendAudioStream = async (audioStream, websocket) => {\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const source = audioContext.createMediaStreamSource(audioStream);\n  const processor = audioContext.createScriptProcessor(4096, 1, 1);\n  processor.onaudioprocess = event => {\n    const audioData = event.inputBuffer.getChannelData(0); // Get the audio data\n    const audioBuffer = new Float32Array(audioData.length);\n    audioBuffer.set(audioData);\n\n    // Send the audio buffer over WebSocket\n    websocket.send(audioBuffer.buffer);\n  };\n  source.connect(processor);\n  processor.connect(audioContext.destination);\n};\nexport const listenToConnectionEvents = (conn, username, remoteUsername, database, remoteVideoRef, doCandidate) => {\n  conn.onicecandidate = function (event) {\n    if (event.candidate) {\n      doCandidate(remoteUsername, event.candidate, database, username);\n    }\n  };\n\n  // when a remote user adds stream to the peer connection, we display it\n  conn.ontrack = function (e) {\n    if (remoteVideoRef.srcObject !== e.streams[0]) {\n      remoteVideoRef.srcObject = e.streams[0];\n    }\n  };\n};\nexport const sendAnswer = async (conn, localStream, notif, doAnswer, database, username) => {\n  try {\n    conn.addStream(localStream);\n    const offer = JSON.parse(notif.offer);\n    conn.setRemoteDescription(offer);\n\n    // create an answer to an offer\n    const answer = await conn.createAnswer();\n    conn.setLocalDescription(answer);\n    doAnswer(notif.from, answer, database, username);\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const startCall = (yourConn, notif) => {\n  const answer = JSON.parse(notif.answer);\n  yourConn.setRemoteDescription(answer);\n};\nexport const addCandidate = (yourConn, notif) => {\n  // apply the new received candidate to the connection\n  const candidate = JSON.parse(notif.candidate);\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate));\n};","map":{"version":3,"names":["createOffer","connection","localStream","userToCall","doOffer","database","username","addStream","offer","setLocalDescription","exception","console","error","initiateLocalStream","stream","navigator","mediaDevices","getUserMedia","video","audio","initiateConnection","configuration","iceServers","urls","conn","RTCPeerConnection","sendAudioStream","audioStream","websocket","audioContext","window","AudioContext","webkitAudioContext","source","createMediaStreamSource","processor","createScriptProcessor","onaudioprocess","event","audioData","inputBuffer","getChannelData","audioBuffer","Float32Array","length","set","send","buffer","connect","destination","listenToConnectionEvents","remoteUsername","remoteVideoRef","doCandidate","onicecandidate","candidate","ontrack","e","srcObject","streams","sendAnswer","notif","doAnswer","JSON","parse","setRemoteDescription","answer","createAnswer","from","startCall","yourConn","addCandidate","addIceCandidate","RTCIceCandidate"],"sources":["/Users/rianadutta/Downloads/mchacks12/LiveTranslator/frontend3/reactReminder/src/modules/RTCModule.js"],"sourcesContent":["\nexport const createOffer = async (connection, localStream, userToCall, doOffer, database, username) => {\n  try {\n    connection.addStream(localStream)\n\n    const offer = await connection.createOffer()\n    await connection.setLocalDescription(offer)\n\n    doOffer(userToCall, offer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const initiateLocalStream = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    })\n    return stream\n  } catch (exception) {\n    console.error(exception)\n  }\n}\nexport const initiateConnection = async () => {\n  try {\n    // using Google public stun server\n    var configuration = {\n      iceServers: [{ urls: 'stun:stun2.1.google.com:19302' }]\n    }\n\n    const conn = new RTCPeerConnection(configuration)\n\n    return conn\n  } catch (exception) {\n    console.error(exception)\n  }\n}\nexport const sendAudioStream = async (audioStream, websocket) => {\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const source = audioContext.createMediaStreamSource(audioStream);\n  const processor = audioContext.createScriptProcessor(4096, 1, 1);\n\n  processor.onaudioprocess = (event) => {\n    const audioData = event.inputBuffer.getChannelData(0); // Get the audio data\n    const audioBuffer = new Float32Array(audioData.length);\n    audioBuffer.set(audioData);\n\n    // Send the audio buffer over WebSocket\n    websocket.send(audioBuffer.buffer);\n  };\n\n  source.connect(processor);\n  processor.connect(audioContext.destination);\n};\n\n\nexport const listenToConnectionEvents = (conn, username, remoteUsername, database, remoteVideoRef, doCandidate) => {\n  conn.onicecandidate = function (event) {\n    if (event.candidate) {\n      doCandidate(remoteUsername, event.candidate, database, username)\n    }\n  }\n\n  // when a remote user adds stream to the peer connection, we display it\n  conn.ontrack = function (e) {\n    if (remoteVideoRef.srcObject !== e.streams[0]) {\n      remoteVideoRef.srcObject = e.streams[0]\n    }\n  }\n}\n\nexport const sendAnswer = async (conn, localStream, notif, doAnswer, database, username) => {\n  try {\n    conn.addStream(localStream)\n\n    const offer = JSON.parse(notif.offer)\n    conn.setRemoteDescription(offer)\n\n    // create an answer to an offer\n    const answer = await conn.createAnswer()\n    conn.setLocalDescription(answer)\n\n    doAnswer(notif.from, answer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const startCall = (yourConn, notif) => {\n  const answer = JSON.parse(notif.answer)\n  yourConn.setRemoteDescription(answer)\n}\n\nexport const addCandidate = (yourConn, notif) => {\n  // apply the new received candidate to the connection\n  const candidate = JSON.parse(notif.candidate)\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate))\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}