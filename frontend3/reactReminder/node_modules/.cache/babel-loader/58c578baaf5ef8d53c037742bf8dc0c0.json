{"ast":null,"code":"import _slicedToArray from \"/Users/rianadutta/Downloads/mchacks12/LiveTranslator/frontend3/reactReminder/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { stringifyCollection } from '../stringify/stringifyCollection.js';\nimport { addPairToJSMap } from './addPairToJSMap.js';\nimport { Collection } from './Collection.js';\nimport { isPair, isScalar, MAP } from './identity.js';\nimport { Pair, createPair } from './Pair.js';\nimport { isScalarValue } from './Scalar.js';\nfunction findPair(items, key) {\n  const k = isScalar(key) ? key.value : key;\n  for (const it of items) {\n    if (isPair(it)) {\n      if (it.key === key || it.key === k) return it;\n      if (isScalar(it.key) && it.key.value === k) return it;\n    }\n  }\n  return undefined;\n}\nclass YAMLMap extends Collection {\n  static get tagName() {\n    return 'tag:yaml.org,2002:map';\n  }\n  constructor(schema) {\n    super(MAP, schema);\n    this.items = [];\n  }\n  /**\n   * A generic collection parsing method that can be extended\n   * to other node classes that inherit from YAMLMap\n   */\n  static from(schema, obj, ctx) {\n    const keepUndefined = ctx.keepUndefined,\n      replacer = ctx.replacer;\n    const map = new this(schema);\n    const add = (key, value) => {\n      if (typeof replacer === 'function') value = replacer.call(obj, key, value);else if (Array.isArray(replacer) && !replacer.includes(key)) return;\n      if (value !== undefined || keepUndefined) map.items.push(createPair(key, value, ctx));\n    };\n    if (obj instanceof Map) {\n      for (const _ref of obj) {\n        var _ref2 = _slicedToArray(_ref, 2);\n        const key = _ref2[0];\n        const value = _ref2[1];\n        add(key, value);\n      }\n    } else if (obj && typeof obj === 'object') {\n      for (const key of Object.keys(obj)) add(key, obj[key]);\n    }\n    if (typeof schema.sortMapEntries === 'function') {\n      map.items.sort(schema.sortMapEntries);\n    }\n    return map;\n  }\n  /**\n   * Adds a value to the collection.\n   *\n   * @param overwrite - If not set `true`, using a key that is already in the\n   *   collection will throw. Otherwise, overwrites the previous value.\n   */\n  add(pair, overwrite) {\n    let _pair;\n    if (isPair(pair)) _pair = pair;else if (!pair || typeof pair !== 'object' || !('key' in pair)) {\n      // In TypeScript, this never happens.\n      _pair = new Pair(pair, pair?.value);\n    } else _pair = new Pair(pair.key, pair.value);\n    const prev = findPair(this.items, _pair.key);\n    const sortEntries = this.schema?.sortMapEntries;\n    if (prev) {\n      if (!overwrite) throw new Error(\"Key \".concat(_pair.key, \" already set\"));\n      // For scalars, keep the old node & its comments and anchors\n      if (isScalar(prev.value) && isScalarValue(_pair.value)) prev.value.value = _pair.value;else prev.value = _pair.value;\n    } else if (sortEntries) {\n      const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);\n      if (i === -1) this.items.push(_pair);else this.items.splice(i, 0, _pair);\n    } else {\n      this.items.push(_pair);\n    }\n  }\n  delete(key) {\n    const it = findPair(this.items, key);\n    if (!it) return false;\n    const del = this.items.splice(this.items.indexOf(it), 1);\n    return del.length > 0;\n  }\n  get(key, keepScalar) {\n    const it = findPair(this.items, key);\n    const node = it?.value;\n    return (!keepScalar && isScalar(node) ? node.value : node) ?? undefined;\n  }\n  has(key) {\n    return !!findPair(this.items, key);\n  }\n  set(key, value) {\n    this.add(new Pair(key, value), true);\n  }\n  /**\n   * @param ctx - Conversion context, originally set in Document#toJS()\n   * @param {Class} Type - If set, forces the returned collection type\n   * @returns Instance of Type, Map, or Object\n   */\n  toJSON(_, ctx, Type) {\n    const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};\n    if (ctx?.onCreate) ctx.onCreate(map);\n    for (const item of this.items) addPairToJSMap(ctx, map, item);\n    return map;\n  }\n  toString(ctx, onComment, onChompKeep) {\n    if (!ctx) return JSON.stringify(this);\n    for (const item of this.items) {\n      if (!isPair(item)) throw new Error(\"Map items must all be pairs; found \".concat(JSON.stringify(item), \" instead\"));\n    }\n    if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, {\n      allNullValues: true\n    });\n    return stringifyCollection(this, ctx, {\n      blockItemPrefix: '',\n      flowChars: {\n        start: '{',\n        end: '}'\n      },\n      itemIndent: ctx.indent || '',\n      onChompKeep,\n      onComment\n    });\n  }\n}\nexport { YAMLMap, findPair };","map":null,"metadata":{},"sourceType":"module"}