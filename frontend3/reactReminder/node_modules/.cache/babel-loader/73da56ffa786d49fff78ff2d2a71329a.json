{"ast":null,"code":"'use strict';\n\n/**\n * `rawlist` type prompt\n */\nconst chalk = require('chalk');\nconst _require = require('rxjs/operators'),\n  map = _require.map,\n  takeUntil = _require.takeUntil;\nconst Base = require('./base');\nconst Separator = require('../objects/separator');\nconst observe = require('../utils/events');\nconst Paginator = require('../utils/paginator');\nclass ExpandPrompt extends Base {\n  constructor(questions, rl, answers) {\n    super(questions, rl, answers);\n    if (!this.opt.choices) {\n      this.throwParamError('choices');\n    }\n    this.validateChoices(this.opt.choices);\n\n    // Add the default `help` (/expand) option\n    this.opt.choices.push({\n      key: 'h',\n      name: 'Help, list all options',\n      value: 'help'\n    });\n    this.opt.validate = choice => {\n      if (choice == null) {\n        return 'Please enter a valid command';\n      }\n      return choice !== 'help';\n    };\n\n    // Setup the default string (capitalize the default key)\n    this.opt.default = this.generateChoicesString(this.opt.choices, this.opt.default);\n    this.paginator = new Paginator(this.screen);\n  }\n\n  /**\n   * Start the Inquiry session\n   * @param  {Function} cb      Callback when prompt is done\n   * @return {this}\n   */\n\n  _run(cb) {\n    this.done = cb;\n\n    // Save user answer and update prompt to show selected option.\n    const events = observe(this.rl);\n    const validation = this.handleSubmitEvents(events.line.pipe(map(this.getCurrentValue.bind(this))));\n    validation.success.forEach(this.onSubmit.bind(this));\n    validation.error.forEach(this.onError.bind(this));\n    this.keypressObs = events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));\n\n    // Init the prompt\n    this.render();\n    return this;\n  }\n\n  /**\n   * Render the prompt to screen\n   * @return {ExpandPrompt} self\n   */\n\n  render(error, hint) {\n    let message = this.getQuestion();\n    let bottomContent = '';\n    if (this.status === 'answered') {\n      message += chalk.cyan(this.answer);\n    } else if (this.status === 'expanded') {\n      const choicesStr = renderChoices(this.opt.choices, this.selectedKey);\n      message += this.paginator.paginate(choicesStr, this.selectedKey, this.opt.pageSize);\n      message += '\\n  Answer: ';\n    }\n    message += this.rl.line;\n    if (error) {\n      bottomContent = chalk.red('>> ') + error;\n    }\n    if (hint) {\n      bottomContent = chalk.cyan('>> ') + hint;\n    }\n    this.screen.render(message, bottomContent);\n  }\n  getCurrentValue(input) {\n    if (!input) {\n      input = this.rawDefault;\n    }\n    const selected = this.opt.choices.where({\n      key: input.toLowerCase().trim()\n    })[0];\n    if (!selected) {\n      return null;\n    }\n    return selected.value;\n  }\n\n  /**\n   * Generate the prompt choices string\n   * @return {String}  Choices string\n   */\n\n  getChoices() {\n    let output = '';\n    this.opt.choices.forEach(choice => {\n      output += '\\n  ';\n      if (choice.type === 'separator') {\n        output += ' ' + choice;\n        return;\n      }\n      let choiceStr = choice.key + ') ' + choice.name;\n      if (this.selectedKey === choice.key) {\n        choiceStr = chalk.cyan(choiceStr);\n      }\n      output += choiceStr;\n    });\n    return output;\n  }\n  onError(state) {\n    if (state.value === 'help') {\n      this.selectedKey = '';\n      this.status = 'expanded';\n      this.render();\n      return;\n    }\n    this.render(state.isValid);\n  }\n\n  /**\n   * When user press `enter` key\n   */\n\n  onSubmit(state) {\n    this.status = 'answered';\n    const choice = this.opt.choices.where({\n      value: state.value\n    })[0];\n    this.answer = choice.short || choice.name;\n\n    // Re-render prompt\n    this.render();\n    this.screen.done();\n    this.done(state.value);\n  }\n\n  /**\n   * When user press a key\n   */\n\n  onKeypress() {\n    this.selectedKey = this.rl.line.toLowerCase();\n    const selected = this.opt.choices.where({\n      key: this.selectedKey\n    })[0];\n    if (this.status === 'expanded') {\n      this.render();\n    } else {\n      this.render(null, selected ? selected.name : null);\n    }\n  }\n\n  /**\n   * Validate the choices\n   * @param {Array} choices\n   */\n\n  validateChoices(choices) {\n    let formatError;\n    const errors = [];\n    const keymap = {};\n    choices.filter(Separator.exclude).forEach(choice => {\n      if (!choice.key || choice.key.length !== 1) {\n        formatError = true;\n      }\n      choice.key = String(choice.key).toLowerCase();\n      if (keymap[choice.key]) {\n        errors.push(choice.key);\n      }\n      keymap[choice.key] = true;\n    });\n    if (formatError) {\n      throw new Error('Format error: `key` param must be a single letter and is required.');\n    }\n    if (keymap.h) {\n      throw new Error('Reserved key error: `key` param cannot be `h` - this value is reserved.');\n    }\n    if (errors.length) {\n      throw new Error('Duplicate key error: `key` param must be unique. Duplicates: ' + [...new Set(errors)].join(','));\n    }\n  }\n\n  /**\n   * Generate a string out of the choices keys\n   * @param  {Array}  choices\n   * @param  {Number|String} default - the choice index or name to capitalize\n   * @return {String} The rendered choices key string\n   */\n  generateChoicesString(choices, defaultChoice) {\n    let defIndex = choices.realLength - 1;\n    if (typeof defaultChoice === 'number' && this.opt.choices.getChoice(defaultChoice)) {\n      defIndex = defaultChoice;\n    } else if (typeof defaultChoice === 'string') {\n      const index = choices.realChoices.findIndex(({\n        value\n      }) => value === defaultChoice);\n      defIndex = index === -1 ? defIndex : index;\n    }\n    const defStr = this.opt.choices.pluck('key');\n    this.rawDefault = defStr[defIndex];\n    defStr[defIndex] = String(defStr[defIndex]).toUpperCase();\n    return defStr.join('');\n  }\n}\n\n/**\n * Function for rendering checkbox choices\n * @param  {String} pointer Selected key\n * @return {String}         Rendered content\n */\n\nfunction renderChoices(choices, pointer) {\n  let output = '';\n  choices.forEach(choice => {\n    output += '\\n  ';\n    if (choice.type === 'separator') {\n      output += ' ' + choice;\n      return;\n    }\n    let choiceStr = choice.key + ') ' + choice.name;\n    if (pointer === choice.key) {\n      choiceStr = chalk.cyan(choiceStr);\n    }\n    output += choiceStr;\n  });\n  return output;\n}\nmodule.exports = ExpandPrompt;","map":null,"metadata":{},"sourceType":"script"}