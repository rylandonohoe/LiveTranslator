{"ast":null,"code":"// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\nvar process = global.process;\nconst processOk = function (process) {\n  return process && typeof process === 'object' && typeof process.removeListener === 'function' && typeof process.emit === 'function' && typeof process.reallyExit === 'function' && typeof process.listeners === 'function' && typeof process.kill === 'function' && typeof process.pid === 'number' && typeof process.on === 'function';\n};\n\n// some kind of non-node environment, just no-op\n/* istanbul ignore if */\nif (!processOk(process)) {\n  module.exports = function () {\n    return function () {};\n  };\n} else {\n  var assert = require('assert');\n  var signals = require('./signals.js');\n  var isWin = /^win/i.test(process.platform);\n  var EE = require('events');\n  /* istanbul ignore if */\n  if (typeof EE !== 'function') {\n    EE = EE.EventEmitter;\n  }\n  var emitter;\n  if (process.__signal_exit_emitter__) {\n    emitter = process.__signal_exit_emitter__;\n  } else {\n    emitter = process.__signal_exit_emitter__ = new EE();\n    emitter.count = 0;\n    emitter.emitted = {};\n  }\n\n  // Because this emitter is a global, we have to check to see if a\n  // previous version of this library failed to enable infinite listeners.\n  // I know what you're about to say.  But literally everything about\n  // signal-exit is a compromise with evil.  Get used to it.\n  if (!emitter.infinite) {\n    emitter.setMaxListeners(Infinity);\n    emitter.infinite = true;\n  }\n  module.exports = function (cb, opts) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return function () {};\n    }\n    assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler');\n    if (loaded === false) {\n      load();\n    }\n    var ev = 'exit';\n    if (opts && opts.alwaysLast) {\n      ev = 'afterexit';\n    }\n    var remove = function () {\n      emitter.removeListener(ev, cb);\n      if (emitter.listeners('exit').length === 0 && emitter.listeners('afterexit').length === 0) {\n        unload();\n      }\n    };\n    emitter.on(ev, cb);\n    return remove;\n  };\n  var unload = function unload() {\n    if (!loaded || !processOk(global.process)) {\n      return;\n    }\n    loaded = false;\n    signals.forEach(function (sig) {\n      try {\n        process.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    });\n    process.emit = originalProcessEmit;\n    process.reallyExit = originalProcessReallyExit;\n    emitter.count -= 1;\n  };\n  module.exports.unload = unload;\n  var emit = function emit(event, code, signal) {\n    /* istanbul ignore if */\n    if (emitter.emitted[event]) {\n      return;\n    }\n    emitter.emitted[event] = true;\n    emitter.emit(event, code, signal);\n  };\n\n  // { <signal>: <listener fn>, ... }\n  var sigListeners = {};\n  signals.forEach(function (sig) {\n    sigListeners[sig] = function listener() {\n      /* istanbul ignore if */\n      if (!processOk(global.process)) {\n        return;\n      }\n      // If there are no other listeners, an exit is coming!\n      // Simplest way: remove us and then re-send the signal.\n      // We know that this will kill the process, so we can\n      // safely emit now.\n      var listeners = process.listeners(sig);\n      if (listeners.length === emitter.count) {\n        unload();\n        emit('exit', null, sig);\n        /* istanbul ignore next */\n        emit('afterexit', null, sig);\n        /* istanbul ignore next */\n        if (isWin && sig === 'SIGHUP') {\n          // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n          // so use a supported signal instead\n          sig = 'SIGINT';\n        }\n        /* istanbul ignore next */\n        process.kill(process.pid, sig);\n      }\n    };\n  });\n  module.exports.signals = function () {\n    return signals;\n  };\n  var loaded = false;\n  var load = function load() {\n    if (loaded || !processOk(global.process)) {\n      return;\n    }\n    loaded = true;\n\n    // This is the number of onSignalExit's that are in play.\n    // It's important so that we can count the correct number of\n    // listeners on signals, and don't wait for the other one to\n    // handle it instead of us.\n    emitter.count += 1;\n    signals = signals.filter(function (sig) {\n      try {\n        process.on(sig, sigListeners[sig]);\n        return true;\n      } catch (er) {\n        return false;\n      }\n    });\n    process.emit = processEmit;\n    process.reallyExit = processReallyExit;\n  };\n  module.exports.load = load;\n  var originalProcessReallyExit = process.reallyExit;\n  var processReallyExit = function processReallyExit(code) {\n    /* istanbul ignore if */\n    if (!processOk(global.process)) {\n      return;\n    }\n    process.exitCode = code || /* istanbul ignore next */0;\n    emit('exit', process.exitCode, null);\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null);\n    /* istanbul ignore next */\n    originalProcessReallyExit.call(process, process.exitCode);\n  };\n  var originalProcessEmit = process.emit;\n  var processEmit = function processEmit(ev, arg) {\n    if (ev === 'exit' && processOk(global.process)) {\n      /* istanbul ignore else */\n      if (arg !== undefined) {\n        process.exitCode = arg;\n      }\n      var ret = originalProcessEmit.apply(this, arguments);\n      /* istanbul ignore next */\n      emit('exit', process.exitCode, null);\n      /* istanbul ignore next */\n      emit('afterexit', process.exitCode, null);\n      /* istanbul ignore next */\n      return ret;\n    } else {\n      return originalProcessEmit.apply(this, arguments);\n    }\n  };\n}","map":null,"metadata":{},"sourceType":"script"}