{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst assert = require('assert');\nconst isWindows = process.platform === 'win32';\nfunction defaults(options) {\n  const methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m];\n    m = m + 'Sync';\n    options[m] = options[m] || fs[m];\n  });\n  options.maxBusyTries = options.maxBusyTries || 3;\n}\nfunction rimraf(p, options, cb) {\n  let busyTries = 0;\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  assert(p, 'rimraf: missing path');\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required');\n  assert(options, 'rimraf: invalid options argument provided');\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');\n  defaults(options);\n  rimraf_(p, options, function CB(er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') && busyTries < options.maxBusyTries) {\n        busyTries++;\n        const time = busyTries * 100;\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time);\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null;\n    }\n    cb(er);\n  });\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_(p, options, cb) {\n  assert(p);\n  assert(options);\n  assert(typeof cb === 'function');\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null);\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb);\n    }\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb);\n    }\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null);\n        }\n        if (er.code === 'EPERM') {\n          return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb);\n        }\n      }\n      return cb(er);\n    });\n  });\n}\nfunction fixWinEPERM(p, options, er, cb) {\n  assert(p);\n  assert(options);\n  assert(typeof cb === 'function');\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er);\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er);\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb);\n        } else {\n          options.unlink(p, cb);\n        }\n      });\n    }\n  });\n}\nfunction fixWinEPERMSync(p, options, er) {\n  let stats;\n  assert(p);\n  assert(options);\n  try {\n    options.chmodSync(p, 0o666);\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return;\n    } else {\n      throw er;\n    }\n  }\n  try {\n    stats = options.statSync(p);\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return;\n    } else {\n      throw er;\n    }\n  }\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er);\n  } else {\n    options.unlinkSync(p);\n  }\n}\nfunction rmdir(p, options, originalEr, cb) {\n  assert(p);\n  assert(options);\n  assert(typeof cb === 'function');\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb);\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr);\n    } else {\n      cb(er);\n    }\n  });\n}\nfunction rmkids(p, options, cb) {\n  assert(p);\n  assert(options);\n  assert(typeof cb === 'function');\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er);\n    let n = files.length;\n    let errState;\n    if (n === 0) return options.rmdir(p, cb);\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return;\n        }\n        if (er) return cb(errState = er);\n        if (--n === 0) {\n          options.rmdir(p, cb);\n        }\n      });\n    });\n  });\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync(p, options) {\n  let st;\n  options = options || {};\n  defaults(options);\n  assert(p, 'rimraf: missing path');\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string');\n  assert(options, 'rimraf: missing options');\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object');\n  try {\n    st = options.lstatSync(p);\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return;\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er);\n    }\n  }\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null);\n    } else {\n      options.unlinkSync(p);\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return;\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);\n    } else if (er.code !== 'EISDIR') {\n      throw er;\n    }\n    rmdirSync(p, options, er);\n  }\n}\nfunction rmdirSync(p, options, originalEr) {\n  assert(p);\n  assert(options);\n  try {\n    options.rmdirSync(p);\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr;\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options);\n    } else if (er.code !== 'ENOENT') {\n      throw er;\n    }\n  }\n}\nfunction rmkidsSync(p, options) {\n  assert(p);\n  assert(options);\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options));\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now();\n    do {\n      try {\n        const ret = options.rmdirSync(p, options);\n        return ret;\n      } catch {}\n    } while (Date.now() - startTime < 500); // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options);\n    return ret;\n  }\n}\nmodule.exports = rimraf;\nrimraf.sync = rimrafSync;","map":null,"metadata":{},"sourceType":"script"}