{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.logger = exports.vsceLogEmitter = void 0;\nconst winston = require(\"winston\");\nconst vsCodeUtils_1 = require(\"./vsCodeUtils\");\nconst events_1 = require(\"events\");\nexports.vsceLogEmitter = new events_1.EventEmitter();\nfunction expandErrors(logger) {\n  const oldLogFunc = logger.log.bind(logger);\n  const newLogFunc = function (levelOrEntry, message, ...meta) {\n    if (message && message instanceof Error) {\n      message = message.stack || message.message;\n      return oldLogFunc(levelOrEntry, message, ...meta);\n    }\n    return oldLogFunc(levelOrEntry, message, ...meta);\n  };\n  logger.log = newLogFunc;\n  return logger;\n}\nfunction annotateDebugLines(logger) {\n  const debug = logger.debug.bind(logger);\n  const newDebug = function (message, ...meta) {\n    if (typeof message === \"string\") {\n      message = \"[\".concat(new Date().toISOString(), \"] \").concat(message || \"\");\n    }\n    return debug(message, ...meta);\n  };\n  logger.debug = newDebug;\n  return logger;\n}\nfunction maybeUseVSCodeLogger(logger) {\n  if (!(0, vsCodeUtils_1.isVSCodeExtension)()) {\n    return logger;\n  }\n  const oldLogFunc = logger.log.bind(logger);\n  const vsceLogger = function (levelOrEntry, message, ...meta) {\n    if (message) {\n      exports.vsceLogEmitter.emit(\"log\", {\n        level: levelOrEntry,\n        message\n      });\n    } else {\n      exports.vsceLogEmitter.emit(\"log\", levelOrEntry);\n    }\n    return oldLogFunc(levelOrEntry, message, ...meta);\n  };\n  logger.log = vsceLogger;\n  return logger;\n}\nconst rawLogger = winston.createLogger();\nrawLogger.add(new winston.transports.Console({\n  silent: true\n}));\nrawLogger.exitOnError = false;\nexports.logger = maybeUseVSCodeLogger(annotateDebugLines(expandErrors(rawLogger)));","map":null,"metadata":{},"sourceType":"script"}