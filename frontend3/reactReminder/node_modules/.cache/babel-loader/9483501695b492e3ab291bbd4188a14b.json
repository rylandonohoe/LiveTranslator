{"ast":null,"code":"'use strict';\n\nconst isObj = require('is-obj');\nconst disallowedKeys = ['__proto__', 'prototype', 'constructor'];\nconst isValidPath = pathSegments => !pathSegments.some(segment => disallowedKeys.includes(segment));\nfunction getPathSegments(path) {\n  const pathArray = path.split('.');\n  const parts = [];\n  for (let i = 0; i < pathArray.length; i++) {\n    let p = pathArray[i];\n    while (p[p.length - 1] === '\\\\' && pathArray[i + 1] !== undefined) {\n      p = p.slice(0, -1) + '.';\n      p += pathArray[++i];\n    }\n    parts.push(p);\n  }\n  if (!isValidPath(parts)) {\n    return [];\n  }\n  return parts;\n}\nmodule.exports = {\n  get(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return value === undefined ? object : value;\n    }\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n      return;\n    }\n    for (let i = 0; i < pathArray.length; i++) {\n      if (!Object.prototype.propertyIsEnumerable.call(object, pathArray[i])) {\n        return value;\n      }\n      object = object[pathArray[i]];\n      if (object === undefined || object === null) {\n        // `object` is either `undefined` or `null` so we want to stop the loop, and\n        // if this is not the last bit of the path, and\n        // if it did't return `undefined`\n        // it would return `null` if `object` is `null`\n        // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n        if (i !== pathArray.length - 1) {\n          return value;\n        }\n        break;\n      }\n    }\n    return object;\n  },\n  set(object, path, value) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return object;\n    }\n    const root = object;\n    const pathArray = getPathSegments(path);\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n      if (!isObj(object[p])) {\n        object[p] = {};\n      }\n      if (i === pathArray.length - 1) {\n        object[p] = value;\n      }\n      object = object[p];\n    }\n    return root;\n  },\n  delete(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return false;\n    }\n    const pathArray = getPathSegments(path);\n    for (let i = 0; i < pathArray.length; i++) {\n      const p = pathArray[i];\n      if (i === pathArray.length - 1) {\n        delete object[p];\n        return true;\n      }\n      object = object[p];\n      if (!isObj(object)) {\n        return false;\n      }\n    }\n  },\n  has(object, path) {\n    if (!isObj(object) || typeof path !== 'string') {\n      return false;\n    }\n    const pathArray = getPathSegments(path);\n    if (pathArray.length === 0) {\n      return false;\n    }\n\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let i = 0; i < pathArray.length; i++) {\n      if (isObj(object)) {\n        if (!(pathArray[i] in object)) {\n          return false;\n        }\n        object = object[pathArray[i]];\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}