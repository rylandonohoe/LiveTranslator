{"ast":null,"code":"'use strict';\n\n/**\n * `rawlist` type prompt\n */\nconst chalk = require('chalk');\nconst _require = require('rxjs/operators'),\n  map = _require.map,\n  takeUntil = _require.takeUntil;\nconst Base = require('./base');\nconst Separator = require('../objects/separator');\nconst observe = require('../utils/events');\nconst Paginator = require('../utils/paginator');\nconst incrementListIndex = require('../utils/incrementListIndex');\nclass RawListPrompt extends Base {\n  constructor(questions, rl, answers) {\n    super(questions, rl, answers);\n    this.hiddenLine = '';\n    this.lastKey = '';\n    if (!this.opt.choices) {\n      this.throwParamError('choices');\n    }\n    this.opt.validChoices = this.opt.choices.filter(Separator.exclude);\n    this.selected = 0;\n    this.rawDefault = 0;\n    Object.assign(this.opt, {\n      validate(val) {\n        return val != null;\n      }\n    });\n    const def = this.opt.default;\n    if (typeof def === 'number' && def >= 0 && def < this.opt.choices.realLength) {\n      this.selected = def;\n      this.rawDefault = def;\n    } else if (typeof def !== 'number' && def != null) {\n      const index = this.opt.choices.realChoices.findIndex(({\n        value\n      }) => value === def);\n      const safeIndex = Math.max(index, 0);\n      this.selected = safeIndex;\n      this.rawDefault = safeIndex;\n    }\n\n    // Make sure no default is set (so it won't be printed)\n    this.opt.default = null;\n    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;\n    this.paginator = new Paginator(undefined, {\n      isInfinite: shouldLoop\n    });\n  }\n\n  /**\n   * Start the Inquiry session\n   * @param  {Function} cb      Callback when prompt is done\n   * @return {this}\n   */\n\n  _run(cb) {\n    this.done = cb;\n\n    // Once user confirm (enter key)\n    const events = observe(this.rl);\n    const submit = events.line.pipe(map(this.getCurrentValue.bind(this)));\n    const validation = this.handleSubmitEvents(submit);\n    validation.success.forEach(this.onEnd.bind(this));\n    validation.error.forEach(this.onError.bind(this));\n    events.normalizedUpKey.pipe(takeUntil(validation.success)).forEach(this.onUpKey.bind(this));\n    events.normalizedDownKey.pipe(takeUntil(validation.success)).forEach(this.onDownKey.bind(this));\n    events.keypress.pipe(takeUntil(validation.success)).forEach(this.onKeypress.bind(this));\n    // Init the prompt\n    this.render();\n    return this;\n  }\n\n  /**\n   * Render the prompt to screen\n   * @return {RawListPrompt} self\n   */\n\n  render(error) {\n    // Render question\n    let message = this.getQuestion();\n    let bottomContent = '';\n    if (this.status === 'answered') {\n      message += chalk.cyan(this.opt.choices.getChoice(this.selected).short);\n    } else {\n      const choicesStr = renderChoices(this.opt.choices, this.selected);\n      message += '\\n' + this.paginator.paginate(choicesStr, this.selected, this.opt.pageSize);\n      message += '\\n  Answer: ';\n    }\n    message += this.rl.line;\n    if (error) {\n      bottomContent = '\\n' + chalk.red('>> ') + error;\n    }\n    this.screen.render(message, bottomContent);\n  }\n\n  /**\n   * When user press `enter` key\n   */\n\n  getCurrentValue(index) {\n    if (index == null) {\n      index = this.rawDefault;\n    } else if (index === '') {\n      this.selected = this.selected === undefined ? -1 : this.selected;\n      index = this.selected;\n    } else {\n      index -= 1;\n    }\n    const choice = this.opt.choices.getChoice(index);\n    return choice ? choice.value : null;\n  }\n  onEnd(state) {\n    this.status = 'answered';\n    this.answer = state.value;\n\n    // Re-render prompt\n    this.render();\n    this.screen.done();\n    this.done(state.value);\n  }\n  onError() {\n    this.render('Please enter a valid index');\n  }\n\n  /**\n   * When user press a key\n   */\n\n  onKeypress() {\n    let index;\n    if (this.lastKey === 'arrow') {\n      index = this.hiddenLine.length ? Number(this.hiddenLine) - 1 : 0;\n    } else {\n      index = this.rl.line.length ? Number(this.rl.line) - 1 : 0;\n    }\n    this.lastKey = '';\n    if (this.opt.choices.getChoice(index)) {\n      this.selected = index;\n    } else {\n      this.selected = undefined;\n    }\n    this.render();\n  }\n\n  /**\n   * When user press up key\n   */\n\n  onUpKey() {\n    this.onArrowKey('up');\n  }\n\n  /**\n   * When user press down key\n   */\n\n  onDownKey() {\n    this.onArrowKey('down');\n  }\n\n  /**\n   * When user press up or down key\n   * @param {String} type Arrow type: up or down\n   */\n\n  onArrowKey(type) {\n    this.selected = incrementListIndex(this.selected, type, this.opt) || 0;\n    this.hiddenLine = String(this.selected + 1);\n    this.rl.line = '';\n    this.lastKey = 'arrow';\n  }\n}\n\n/**\n * Function for rendering list choices\n * @param  {Number} pointer Position of the pointer\n * @return {String}         Rendered content\n */\n\nfunction renderChoices(choices, pointer) {\n  let output = '';\n  let separatorOffset = 0;\n  choices.forEach((choice, i) => {\n    output += output ? '\\n  ' : '  ';\n    if (choice.type === 'separator') {\n      separatorOffset++;\n      output += ' ' + choice;\n      return;\n    }\n    const index = i - separatorOffset;\n    let display = index + 1 + ') ' + choice.name;\n    if (index === pointer) {\n      display = chalk.cyan(display);\n    }\n    output += display;\n  });\n  return output;\n}\nmodule.exports = RawListPrompt;","map":null,"metadata":{},"sourceType":"script"}