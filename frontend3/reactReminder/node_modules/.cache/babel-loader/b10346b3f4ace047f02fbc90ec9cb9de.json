{"ast":null,"code":"import { tokenType } from './cst.js';\nimport { Lexer } from './lexer.js';\nfunction includesToken(list, type) {\n  for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;\n  return false;\n}\nfunction findNonEmptyIndex(list) {\n  for (let i = 0; i < list.length; ++i) {\n    switch (list[i].type) {\n      case 'space':\n      case 'comment':\n      case 'newline':\n        break;\n      default:\n        return i;\n    }\n  }\n  return -1;\n}\nfunction isFlowToken(token) {\n  switch (token?.type) {\n    case 'alias':\n    case 'scalar':\n    case 'single-quoted-scalar':\n    case 'double-quoted-scalar':\n    case 'flow-collection':\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getPrevProps(parent) {\n  switch (parent.type) {\n    case 'document':\n      return parent.start;\n    case 'block-map':\n      {\n        const it = parent.items[parent.items.length - 1];\n        return it.sep ?? it.start;\n      }\n    case 'block-seq':\n      return parent.items[parent.items.length - 1].start;\n    /* istanbul ignore next should not happen */\n    default:\n      return [];\n  }\n}\n/** Note: May modify input array */\nfunction getFirstKeyStartProps(prev) {\n  if (prev.length === 0) return [];\n  let i = prev.length;\n  loop: while (--i >= 0) {\n    switch (prev[i].type) {\n      case 'doc-start':\n      case 'explicit-key-ind':\n      case 'map-value-ind':\n      case 'seq-item-ind':\n      case 'newline':\n        break loop;\n    }\n  }\n  while (prev[++i]?.type === 'space') {\n    /* loop */\n  }\n  return prev.splice(i, prev.length);\n}\nfunction fixFlowSeqItems(fc) {\n  if (fc.start.type === 'flow-seq-start') {\n    for (const it of fc.items) {\n      if (it.sep && !it.value && !includesToken(it.start, 'explicit-key-ind') && !includesToken(it.sep, 'map-value-ind')) {\n        if (it.key) it.value = it.key;\n        delete it.key;\n        if (isFlowToken(it.value)) {\n          if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);else it.value.end = it.sep;\n        } else Array.prototype.push.apply(it.start, it.sep);\n        delete it.sep;\n      }\n    }\n  }\n}\n/**\n * A YAML concrete syntax tree (CST) parser\n *\n * ```ts\n * const src: string = ...\n * for (const token of new Parser().parse(src)) {\n *   // token: Token\n * }\n * ```\n *\n * To use the parser with a user-provided lexer:\n *\n * ```ts\n * function* parse(source: string, lexer: Lexer) {\n *   const parser = new Parser()\n *   for (const lexeme of lexer.lex(source))\n *     yield* parser.next(lexeme)\n *   yield* parser.end()\n * }\n *\n * const src: string = ...\n * const lexer = new Lexer()\n * for (const token of parse(src, lexer)) {\n *   // token: Token\n * }\n * ```\n */\nclass Parser {\n  /**\n   * @param onNewLine - If defined, called separately with the start position of\n   *   each new line (in `parse()`, including the start of input).\n   */\n  constructor(onNewLine) {\n    /** If true, space and sequence indicators count as indentation */\n    this.atNewLine = true;\n    /** If true, next token is a scalar value */\n    this.atScalar = false;\n    /** Current indentation level */\n    this.indent = 0;\n    /** Current offset since the start of parsing */\n    this.offset = 0;\n    /** On the same line with a block map key */\n    this.onKeyLine = false;\n    /** Top indicates the node that's currently being built */\n    this.stack = [];\n    /** The source of the current token, set in parse() */\n    this.source = '';\n    /** The type of the current token, set in parse() */\n    this.type = '';\n    // Must be defined after `next()`\n    this.lexer = new Lexer();\n    this.onNewLine = onNewLine;\n  }\n  /**\n   * Parse `source` as a YAML stream.\n   * If `incomplete`, a part of the last line may be left as a buffer for the next call.\n   *\n   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.\n   *\n   * @returns A generator of tokens representing each directive, document, and other structure.\n   */\n  *parse(source, incomplete = false) {\n    if (this.onNewLine && this.offset === 0) this.onNewLine(0);\n    for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);\n    if (!incomplete) yield* this.end();\n  }\n  /**\n   * Advance the parser by the `source` of one lexical token.\n   */\n  *next(source) {\n    this.source = source;\n    if (this.atScalar) {\n      this.atScalar = false;\n      yield* this.step();\n      this.offset += source.length;\n      return;\n    }\n    const type = tokenType(source);\n    if (!type) {\n      const message = \"Not a YAML token: \".concat(source);\n      yield* this.pop({\n        type: 'error',\n        offset: this.offset,\n        message,\n        source\n      });\n      this.offset += source.length;\n    } else if (type === 'scalar') {\n      this.atNewLine = false;\n      this.atScalar = true;\n      this.type = 'scalar';\n    } else {\n      this.type = type;\n      yield* this.step();\n      switch (type) {\n        case 'newline':\n          this.atNewLine = true;\n          this.indent = 0;\n          if (this.onNewLine) this.onNewLine(this.offset + source.length);\n          break;\n        case 'space':\n          if (this.atNewLine && source[0] === ' ') this.indent += source.length;\n          break;\n        case 'explicit-key-ind':\n        case 'map-value-ind':\n        case 'seq-item-ind':\n          if (this.atNewLine) this.indent += source.length;\n          break;\n        case 'doc-mode':\n        case 'flow-error-end':\n          return;\n        default:\n          this.atNewLine = false;\n      }\n      this.offset += source.length;\n    }\n  }\n  /** Call at end of input to push out any remaining constructions */\n  *end() {\n    while (this.stack.length > 0) yield* this.pop();\n  }\n  get sourceToken() {\n    const st = {\n      type: this.type,\n      offset: this.offset,\n      indent: this.indent,\n      source: this.source\n    };\n    return st;\n  }\n  *step() {\n    const top = this.peek(1);\n    if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {\n      while (this.stack.length > 0) yield* this.pop();\n      this.stack.push({\n        type: 'doc-end',\n        offset: this.offset,\n        source: this.source\n      });\n      return;\n    }\n    if (!top) return yield* this.stream();\n    switch (top.type) {\n      case 'document':\n        return yield* this.document(top);\n      case 'alias':\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return yield* this.scalar(top);\n      case 'block-scalar':\n        return yield* this.blockScalar(top);\n      case 'block-map':\n        return yield* this.blockMap(top);\n      case 'block-seq':\n        return yield* this.blockSequence(top);\n      case 'flow-collection':\n        return yield* this.flowCollection(top);\n      case 'doc-end':\n        return yield* this.documentEnd(top);\n    }\n    /* istanbul ignore next should not happen */\n    yield* this.pop();\n  }\n  peek(n) {\n    return this.stack[this.stack.length - n];\n  }\n  *pop(error) {\n    const token = error ?? this.stack.pop();\n    /* istanbul ignore if should not happen */\n    if (!token) {\n      const message = 'Tried to pop an empty stack';\n      yield {\n        type: 'error',\n        offset: this.offset,\n        source: '',\n        message\n      };\n    } else if (this.stack.length === 0) {\n      yield token;\n    } else {\n      const top = this.peek(1);\n      if (token.type === 'block-scalar') {\n        // Block scalars use their parent rather than header indent\n        token.indent = 'indent' in top ? top.indent : 0;\n      } else if (token.type === 'flow-collection' && top.type === 'document') {\n        // Ignore all indent for top-level flow collections\n        token.indent = 0;\n      }\n      if (token.type === 'flow-collection') fixFlowSeqItems(token);\n      switch (top.type) {\n        case 'document':\n          top.value = token;\n          break;\n        case 'block-scalar':\n          top.props.push(token); // error\n          break;\n        case 'block-map':\n          {\n            const it = top.items[top.items.length - 1];\n            if (it.value) {\n              top.items.push({\n                start: [],\n                key: token,\n                sep: []\n              });\n              this.onKeyLine = true;\n              return;\n            } else if (it.sep) {\n              it.value = token;\n            } else {\n              Object.assign(it, {\n                key: token,\n                sep: []\n              });\n              this.onKeyLine = !it.explicitKey;\n              return;\n            }\n            break;\n          }\n        case 'block-seq':\n          {\n            const it = top.items[top.items.length - 1];\n            if (it.value) top.items.push({\n              start: [],\n              value: token\n            });else it.value = token;\n            break;\n          }\n        case 'flow-collection':\n          {\n            const it = top.items[top.items.length - 1];\n            if (!it || it.value) top.items.push({\n              start: [],\n              key: token,\n              sep: []\n            });else if (it.sep) it.value = token;else Object.assign(it, {\n              key: token,\n              sep: []\n            });\n            return;\n          }\n        /* istanbul ignore next should not happen */\n        default:\n          yield* this.pop();\n          yield* this.pop(token);\n      }\n      if ((top.type === 'document' || top.type === 'block-map' || top.type === 'block-seq') && (token.type === 'block-map' || token.type === 'block-seq')) {\n        const last = token.items[token.items.length - 1];\n        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {\n          if (top.type === 'document') top.end = last.start;else top.items.push({\n            start: last.start\n          });\n          token.items.splice(-1, 1);\n        }\n      }\n    }\n  }\n  *stream() {\n    switch (this.type) {\n      case 'directive-line':\n        yield {\n          type: 'directive',\n          offset: this.offset,\n          source: this.source\n        };\n        return;\n      case 'byte-order-mark':\n      case 'space':\n      case 'comment':\n      case 'newline':\n        yield this.sourceToken;\n        return;\n      case 'doc-mode':\n      case 'doc-start':\n        {\n          const doc = {\n            type: 'document',\n            offset: this.offset,\n            start: []\n          };\n          if (this.type === 'doc-start') doc.start.push(this.sourceToken);\n          this.stack.push(doc);\n          return;\n        }\n    }\n    yield {\n      type: 'error',\n      offset: this.offset,\n      message: \"Unexpected \".concat(this.type, \" token in YAML stream\"),\n      source: this.source\n    };\n  }\n  *document(doc) {\n    if (doc.value) return yield* this.lineEnd(doc);\n    switch (this.type) {\n      case 'doc-start':\n        {\n          if (findNonEmptyIndex(doc.start) !== -1) {\n            yield* this.pop();\n            yield* this.step();\n          } else doc.start.push(this.sourceToken);\n          return;\n        }\n      case 'anchor':\n      case 'tag':\n      case 'space':\n      case 'comment':\n      case 'newline':\n        doc.start.push(this.sourceToken);\n        return;\n    }\n    const bv = this.startBlockValue(doc);\n    if (bv) this.stack.push(bv);else {\n      yield {\n        type: 'error',\n        offset: this.offset,\n        message: \"Unexpected \".concat(this.type, \" token in YAML document\"),\n        source: this.source\n      };\n    }\n  }\n  *scalar(scalar) {\n    if (this.type === 'map-value-ind') {\n      const prev = getPrevProps(this.peek(2));\n      const start = getFirstKeyStartProps(prev);\n      let sep;\n      if (scalar.end) {\n        sep = scalar.end;\n        sep.push(this.sourceToken);\n        delete scalar.end;\n      } else sep = [this.sourceToken];\n      const map = {\n        type: 'block-map',\n        offset: scalar.offset,\n        indent: scalar.indent,\n        items: [{\n          start,\n          key: scalar,\n          sep\n        }]\n      };\n      this.onKeyLine = true;\n      this.stack[this.stack.length - 1] = map;\n    } else yield* this.lineEnd(scalar);\n  }\n  *blockScalar(scalar) {\n    switch (this.type) {\n      case 'space':\n      case 'comment':\n      case 'newline':\n        scalar.props.push(this.sourceToken);\n        return;\n      case 'scalar':\n        scalar.source = this.source;\n        // block-scalar source includes trailing newline\n        this.atNewLine = true;\n        this.indent = 0;\n        if (this.onNewLine) {\n          let nl = this.source.indexOf('\\n') + 1;\n          while (nl !== 0) {\n            this.onNewLine(this.offset + nl);\n            nl = this.source.indexOf('\\n', nl) + 1;\n          }\n        }\n        yield* this.pop();\n        break;\n      /* istanbul ignore next should not happen */\n      default:\n        yield* this.pop();\n        yield* this.step();\n    }\n  }\n  *blockMap(map) {\n    const it = map.items[map.items.length - 1];\n    // it.sep is true-ish if pair already has key or : separator\n    switch (this.type) {\n      case 'newline':\n        this.onKeyLine = false;\n        if (it.value) {\n          const end = 'end' in it.value ? it.value.end : undefined;\n          const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n          if (last?.type === 'comment') end?.push(this.sourceToken);else map.items.push({\n            start: [this.sourceToken]\n          });\n        } else if (it.sep) {\n          it.sep.push(this.sourceToken);\n        } else {\n          it.start.push(this.sourceToken);\n        }\n        return;\n      case 'space':\n      case 'comment':\n        if (it.value) {\n          map.items.push({\n            start: [this.sourceToken]\n          });\n        } else if (it.sep) {\n          it.sep.push(this.sourceToken);\n        } else {\n          if (this.atIndentedComment(it.start, map.indent)) {\n            const prev = map.items[map.items.length - 2];\n            const end = prev?.value?.end;\n            if (Array.isArray(end)) {\n              Array.prototype.push.apply(end, it.start);\n              end.push(this.sourceToken);\n              map.items.pop();\n              return;\n            }\n          }\n          it.start.push(this.sourceToken);\n        }\n        return;\n    }\n    if (this.indent >= map.indent) {\n      const atMapIndent = !this.onKeyLine && this.indent === map.indent;\n      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== 'seq-item-ind';\n      // For empty nodes, assign newline-separated not indented empty tokens to following node\n      let start = [];\n      if (atNextItem && it.sep && !it.value) {\n        const nl = [];\n        for (let i = 0; i < it.sep.length; ++i) {\n          const st = it.sep[i];\n          switch (st.type) {\n            case 'newline':\n              nl.push(i);\n              break;\n            case 'space':\n              break;\n            case 'comment':\n              if (st.indent > map.indent) nl.length = 0;\n              break;\n            default:\n              nl.length = 0;\n          }\n        }\n        if (nl.length >= 2) start = it.sep.splice(nl[1]);\n      }\n      switch (this.type) {\n        case 'anchor':\n        case 'tag':\n          if (atNextItem || it.value) {\n            start.push(this.sourceToken);\n            map.items.push({\n              start\n            });\n            this.onKeyLine = true;\n          } else if (it.sep) {\n            it.sep.push(this.sourceToken);\n          } else {\n            it.start.push(this.sourceToken);\n          }\n          return;\n        case 'explicit-key-ind':\n          if (!it.sep && !it.explicitKey) {\n            it.start.push(this.sourceToken);\n            it.explicitKey = true;\n          } else if (atNextItem || it.value) {\n            start.push(this.sourceToken);\n            map.items.push({\n              start,\n              explicitKey: true\n            });\n          } else {\n            this.stack.push({\n              type: 'block-map',\n              offset: this.offset,\n              indent: this.indent,\n              items: [{\n                start: [this.sourceToken],\n                explicitKey: true\n              }]\n            });\n          }\n          this.onKeyLine = true;\n          return;\n        case 'map-value-ind':\n          if (it.explicitKey) {\n            if (!it.sep) {\n              if (includesToken(it.start, 'newline')) {\n                Object.assign(it, {\n                  key: null,\n                  sep: [this.sourceToken]\n                });\n              } else {\n                const start = getFirstKeyStartProps(it.start);\n                this.stack.push({\n                  type: 'block-map',\n                  offset: this.offset,\n                  indent: this.indent,\n                  items: [{\n                    start,\n                    key: null,\n                    sep: [this.sourceToken]\n                  }]\n                });\n              }\n            } else if (it.value) {\n              map.items.push({\n                start: [],\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (includesToken(it.sep, 'map-value-ind')) {\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start,\n                  key: null,\n                  sep: [this.sourceToken]\n                }]\n              });\n            } else if (isFlowToken(it.key) && !includesToken(it.sep, 'newline')) {\n              const start = getFirstKeyStartProps(it.start);\n              const key = it.key;\n              const sep = it.sep;\n              sep.push(this.sourceToken);\n              // @ts-expect-error type guard is wrong here\n              delete it.key;\n              // @ts-expect-error type guard is wrong here\n              delete it.sep;\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start,\n                  key,\n                  sep\n                }]\n              });\n            } else if (start.length > 0) {\n              // Not actually at next item\n              it.sep = it.sep.concat(start, this.sourceToken);\n            } else {\n              it.sep.push(this.sourceToken);\n            }\n          } else {\n            if (!it.sep) {\n              Object.assign(it, {\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (it.value || atNextItem) {\n              map.items.push({\n                start,\n                key: null,\n                sep: [this.sourceToken]\n              });\n            } else if (includesToken(it.sep, 'map-value-ind')) {\n              this.stack.push({\n                type: 'block-map',\n                offset: this.offset,\n                indent: this.indent,\n                items: [{\n                  start: [],\n                  key: null,\n                  sep: [this.sourceToken]\n                }]\n              });\n            } else {\n              it.sep.push(this.sourceToken);\n            }\n          }\n          this.onKeyLine = true;\n          return;\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          {\n            const fs = this.flowScalar(this.type);\n            if (atNextItem || it.value) {\n              map.items.push({\n                start,\n                key: fs,\n                sep: []\n              });\n              this.onKeyLine = true;\n            } else if (it.sep) {\n              this.stack.push(fs);\n            } else {\n              Object.assign(it, {\n                key: fs,\n                sep: []\n              });\n              this.onKeyLine = true;\n            }\n            return;\n          }\n        default:\n          {\n            const bv = this.startBlockValue(map);\n            if (bv) {\n              if (atMapIndent && bv.type !== 'block-seq') {\n                map.items.push({\n                  start\n                });\n              }\n              this.stack.push(bv);\n              return;\n            }\n          }\n      }\n    }\n    yield* this.pop();\n    yield* this.step();\n  }\n  *blockSequence(seq) {\n    const it = seq.items[seq.items.length - 1];\n    switch (this.type) {\n      case 'newline':\n        if (it.value) {\n          const end = 'end' in it.value ? it.value.end : undefined;\n          const last = Array.isArray(end) ? end[end.length - 1] : undefined;\n          if (last?.type === 'comment') end?.push(this.sourceToken);else seq.items.push({\n            start: [this.sourceToken]\n          });\n        } else it.start.push(this.sourceToken);\n        return;\n      case 'space':\n      case 'comment':\n        if (it.value) seq.items.push({\n          start: [this.sourceToken]\n        });else {\n          if (this.atIndentedComment(it.start, seq.indent)) {\n            const prev = seq.items[seq.items.length - 2];\n            const end = prev?.value?.end;\n            if (Array.isArray(end)) {\n              Array.prototype.push.apply(end, it.start);\n              end.push(this.sourceToken);\n              seq.items.pop();\n              return;\n            }\n          }\n          it.start.push(this.sourceToken);\n        }\n        return;\n      case 'anchor':\n      case 'tag':\n        if (it.value || this.indent <= seq.indent) break;\n        it.start.push(this.sourceToken);\n        return;\n      case 'seq-item-ind':\n        if (this.indent !== seq.indent) break;\n        if (it.value || includesToken(it.start, 'seq-item-ind')) seq.items.push({\n          start: [this.sourceToken]\n        });else it.start.push(this.sourceToken);\n        return;\n    }\n    if (this.indent > seq.indent) {\n      const bv = this.startBlockValue(seq);\n      if (bv) {\n        this.stack.push(bv);\n        return;\n      }\n    }\n    yield* this.pop();\n    yield* this.step();\n  }\n  *flowCollection(fc) {\n    const it = fc.items[fc.items.length - 1];\n    if (this.type === 'flow-error-end') {\n      let top;\n      do {\n        yield* this.pop();\n        top = this.peek(1);\n      } while (top && top.type === 'flow-collection');\n    } else if (fc.end.length === 0) {\n      switch (this.type) {\n        case 'comma':\n        case 'explicit-key-ind':\n          if (!it || it.sep) fc.items.push({\n            start: [this.sourceToken]\n          });else it.start.push(this.sourceToken);\n          return;\n        case 'map-value-ind':\n          if (!it || it.value) fc.items.push({\n            start: [],\n            key: null,\n            sep: [this.sourceToken]\n          });else if (it.sep) it.sep.push(this.sourceToken);else Object.assign(it, {\n            key: null,\n            sep: [this.sourceToken]\n          });\n          return;\n        case 'space':\n        case 'comment':\n        case 'newline':\n        case 'anchor':\n        case 'tag':\n          if (!it || it.value) fc.items.push({\n            start: [this.sourceToken]\n          });else if (it.sep) it.sep.push(this.sourceToken);else it.start.push(this.sourceToken);\n          return;\n        case 'alias':\n        case 'scalar':\n        case 'single-quoted-scalar':\n        case 'double-quoted-scalar':\n          {\n            const fs = this.flowScalar(this.type);\n            if (!it || it.value) fc.items.push({\n              start: [],\n              key: fs,\n              sep: []\n            });else if (it.sep) this.stack.push(fs);else Object.assign(it, {\n              key: fs,\n              sep: []\n            });\n            return;\n          }\n        case 'flow-map-end':\n        case 'flow-seq-end':\n          fc.end.push(this.sourceToken);\n          return;\n      }\n      const bv = this.startBlockValue(fc);\n      /* istanbul ignore else should not happen */\n      if (bv) this.stack.push(bv);else {\n        yield* this.pop();\n        yield* this.step();\n      }\n    } else {\n      const parent = this.peek(2);\n      if (parent.type === 'block-map' && (this.type === 'map-value-ind' && parent.indent === fc.indent || this.type === 'newline' && !parent.items[parent.items.length - 1].sep)) {\n        yield* this.pop();\n        yield* this.step();\n      } else if (this.type === 'map-value-ind' && parent.type !== 'flow-collection') {\n        const prev = getPrevProps(parent);\n        const start = getFirstKeyStartProps(prev);\n        fixFlowSeqItems(fc);\n        const sep = fc.end.splice(1, fc.end.length);\n        sep.push(this.sourceToken);\n        const map = {\n          type: 'block-map',\n          offset: fc.offset,\n          indent: fc.indent,\n          items: [{\n            start,\n            key: fc,\n            sep\n          }]\n        };\n        this.onKeyLine = true;\n        this.stack[this.stack.length - 1] = map;\n      } else {\n        yield* this.lineEnd(fc);\n      }\n    }\n  }\n  flowScalar(type) {\n    if (this.onNewLine) {\n      let nl = this.source.indexOf('\\n') + 1;\n      while (nl !== 0) {\n        this.onNewLine(this.offset + nl);\n        nl = this.source.indexOf('\\n', nl) + 1;\n      }\n    }\n    return {\n      type,\n      offset: this.offset,\n      indent: this.indent,\n      source: this.source\n    };\n  }\n  startBlockValue(parent) {\n    switch (this.type) {\n      case 'alias':\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return this.flowScalar(this.type);\n      case 'block-scalar-header':\n        return {\n          type: 'block-scalar',\n          offset: this.offset,\n          indent: this.indent,\n          props: [this.sourceToken],\n          source: ''\n        };\n      case 'flow-map-start':\n      case 'flow-seq-start':\n        return {\n          type: 'flow-collection',\n          offset: this.offset,\n          indent: this.indent,\n          start: this.sourceToken,\n          items: [],\n          end: []\n        };\n      case 'seq-item-ind':\n        return {\n          type: 'block-seq',\n          offset: this.offset,\n          indent: this.indent,\n          items: [{\n            start: [this.sourceToken]\n          }]\n        };\n      case 'explicit-key-ind':\n        {\n          this.onKeyLine = true;\n          const prev = getPrevProps(parent);\n          const start = getFirstKeyStartProps(prev);\n          start.push(this.sourceToken);\n          return {\n            type: 'block-map',\n            offset: this.offset,\n            indent: this.indent,\n            items: [{\n              start,\n              explicitKey: true\n            }]\n          };\n        }\n      case 'map-value-ind':\n        {\n          this.onKeyLine = true;\n          const prev = getPrevProps(parent);\n          const start = getFirstKeyStartProps(prev);\n          return {\n            type: 'block-map',\n            offset: this.offset,\n            indent: this.indent,\n            items: [{\n              start,\n              key: null,\n              sep: [this.sourceToken]\n            }]\n          };\n        }\n    }\n    return null;\n  }\n  atIndentedComment(start, indent) {\n    if (this.type !== 'comment') return false;\n    if (this.indent <= indent) return false;\n    return start.every(st => st.type === 'newline' || st.type === 'space');\n  }\n  *documentEnd(docEnd) {\n    if (this.type !== 'doc-mode') {\n      if (docEnd.end) docEnd.end.push(this.sourceToken);else docEnd.end = [this.sourceToken];\n      if (this.type === 'newline') yield* this.pop();\n    }\n  }\n  *lineEnd(token) {\n    switch (this.type) {\n      case 'comma':\n      case 'doc-start':\n      case 'doc-end':\n      case 'flow-seq-end':\n      case 'flow-map-end':\n      case 'map-value-ind':\n        yield* this.pop();\n        yield* this.step();\n        break;\n      case 'newline':\n        this.onKeyLine = false;\n      // fallthrough\n      case 'space':\n      case 'comment':\n      default:\n        // all other values are errors\n        if (token.end) token.end.push(this.sourceToken);else token.end = [this.sourceToken];\n        if (this.type === 'newline') yield* this.pop();\n    }\n  }\n}\nexport { Parser };","map":null,"metadata":{},"sourceType":"module"}