{"ast":null,"code":"'use strict';\n\nconst fs = require('../fs');\nconst path = require('path');\nconst util = require('util');\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? file => fs.stat(file, {\n    bigint: true\n  }) : file => fs.lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    if (err.code === 'ENOENT') return null;\n    throw err;\n  })]).then(([srcStat, destStat]) => ({\n    srcStat,\n    destStat\n  }));\n}\nfunction getStatsSync(src, dest, opts) {\n  let destStat;\n  const statFunc = opts.dereference ? file => fs.statSync(file, {\n    bigint: true\n  }) : file => fs.lstatSync(file, {\n    bigint: true\n  });\n  const srcStat = statFunc(src);\n  try {\n    destStat = statFunc(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}\nfunction checkPaths(src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err);\n    const srcStat = stats.srcStat,\n      destStat = stats.destStat;\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src);\n        const destBaseName = path.basename(dest);\n        if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, {\n            srcStat,\n            destStat,\n            isChangingCase: true\n          });\n        }\n        return cb(new Error('Source and destination must not be the same.'));\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(\"Cannot overwrite non-directory '\".concat(dest, \"' with directory '\").concat(src, \"'.\")));\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(\"Cannot overwrite directory '\".concat(dest, \"' with non-directory '\").concat(src, \"'.\")));\n      }\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n    return cb(null, {\n      srcStat,\n      destStat\n    });\n  });\n}\nfunction checkPathsSync(src, dest, funcName, opts) {\n  const _getStatsSync = getStatsSync(src, dest, opts),\n    srcStat = _getStatsSync.srcStat,\n    destStat = _getStatsSync.destStat;\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src);\n      const destBaseName = path.basename(dest);\n      if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return {\n          srcStat,\n          destStat,\n          isChangingCase: true\n        };\n      }\n      throw new Error('Source and destination must not be the same.');\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(\"Cannot overwrite non-directory '\".concat(dest, \"' with directory '\").concat(src, \"'.\"));\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(\"Cannot overwrite directory '\".concat(dest, \"' with non-directory '\").concat(src, \"'.\"));\n    }\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths(src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();\n  fs.stat(destParent, {\n    bigint: true\n  }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb();\n      return cb(err);\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb);\n  });\n}\nfunction checkParentPathsSync(src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  let destStat;\n  try {\n    destStat = fs.statSync(destParent, {\n      bigint: true\n    });\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n}\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir(src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i);\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i);\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);\n}\nfunction errMsg(src, dest, funcName) {\n  return \"Cannot \".concat(funcName, \" '\").concat(src, \"' to a subdirectory of itself, '\").concat(dest, \"'.\");\n}\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n};","map":null,"metadata":{},"sourceType":"script"}