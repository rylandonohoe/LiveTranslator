{"ast":null,"code":"import { resolveBlockScalar } from '../compose/resolve-block-scalar.js';\nimport { resolveFlowScalar } from '../compose/resolve-flow-scalar.js';\nimport { YAMLParseError } from '../errors.js';\nimport { stringifyString } from '../stringify/stringifyString.js';\nfunction resolveAsScalar(token, strict = true, onError) {\n  if (token) {\n    const _onError = (pos, code, message) => {\n      const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;\n      if (onError) onError(offset, code, message);else throw new YAMLParseError([offset, offset + 1], code, message);\n    };\n    switch (token.type) {\n      case 'scalar':\n      case 'single-quoted-scalar':\n      case 'double-quoted-scalar':\n        return resolveFlowScalar(token, strict, _onError);\n      case 'block-scalar':\n        return resolveBlockScalar({\n          options: {\n            strict\n          }\n        }, token, _onError);\n    }\n  }\n  return null;\n}\n/**\n * Create a new scalar token with `value`\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.indent The indent level of the token.\n * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.\n * @param context.offset The offset position of the token.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction createScalarToken(value, context) {\n  const _context$implicitKey = context.implicitKey,\n    implicitKey = _context$implicitKey === void 0 ? false : _context$implicitKey,\n    indent = context.indent,\n    _context$inFlow = context.inFlow,\n    inFlow = _context$inFlow === void 0 ? false : _context$inFlow,\n    _context$offset = context.offset,\n    offset = _context$offset === void 0 ? -1 : _context$offset,\n    _context$type = context.type,\n    type = _context$type === void 0 ? 'PLAIN' : _context$type;\n  const source = stringifyString({\n    type,\n    value\n  }, {\n    implicitKey,\n    indent: indent > 0 ? ' '.repeat(indent) : '',\n    inFlow,\n    options: {\n      blockQuote: true,\n      lineWidth: -1\n    }\n  });\n  const end = context.end ?? [{\n    type: 'newline',\n    offset: -1,\n    indent,\n    source: '\\n'\n  }];\n  switch (source[0]) {\n    case '|':\n    case '>':\n      {\n        const he = source.indexOf('\\n');\n        const head = source.substring(0, he);\n        const body = source.substring(he + 1) + '\\n';\n        const props = [{\n          type: 'block-scalar-header',\n          offset,\n          indent,\n          source: head\n        }];\n        if (!addEndtoBlockProps(props, end)) props.push({\n          type: 'newline',\n          offset: -1,\n          indent,\n          source: '\\n'\n        });\n        return {\n          type: 'block-scalar',\n          offset,\n          indent,\n          props,\n          source: body\n        };\n      }\n    case '\"':\n      return {\n        type: 'double-quoted-scalar',\n        offset,\n        indent,\n        source,\n        end\n      };\n    case \"'\":\n      return {\n        type: 'single-quoted-scalar',\n        offset,\n        indent,\n        source,\n        end\n      };\n    default:\n      return {\n        type: 'scalar',\n        offset,\n        indent,\n        source,\n        end\n      };\n  }\n}\n/**\n * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.\n *\n * Best efforts are made to retain any comments previously associated with the `token`,\n * though all contents within a collection's `items` will be overwritten.\n *\n * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,\n * as this function does not support any schema operations and won't check for such conflicts.\n *\n * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.\n * @param value The string representation of the value, which will have its content properly indented.\n * @param context.afterKey In most cases, values after a key should have an additional level of indentation.\n * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.\n * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.\n * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.\n */\nfunction setScalarValue(token, value, context = {}) {\n  let _context$afterKey = context.afterKey,\n    afterKey = _context$afterKey === void 0 ? false : _context$afterKey,\n    _context$implicitKey2 = context.implicitKey,\n    implicitKey = _context$implicitKey2 === void 0 ? false : _context$implicitKey2,\n    _context$inFlow2 = context.inFlow,\n    inFlow = _context$inFlow2 === void 0 ? false : _context$inFlow2,\n    type = context.type;\n  let indent = 'indent' in token ? token.indent : null;\n  if (afterKey && typeof indent === 'number') indent += 2;\n  if (!type) switch (token.type) {\n    case 'single-quoted-scalar':\n      type = 'QUOTE_SINGLE';\n      break;\n    case 'double-quoted-scalar':\n      type = 'QUOTE_DOUBLE';\n      break;\n    case 'block-scalar':\n      {\n        const header = token.props[0];\n        if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');\n        type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';\n        break;\n      }\n    default:\n      type = 'PLAIN';\n  }\n  const source = stringifyString({\n    type,\n    value\n  }, {\n    implicitKey: implicitKey || indent === null,\n    indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',\n    inFlow,\n    options: {\n      blockQuote: true,\n      lineWidth: -1\n    }\n  });\n  switch (source[0]) {\n    case '|':\n    case '>':\n      setBlockScalarValue(token, source);\n      break;\n    case '\"':\n      setFlowScalarValue(token, source, 'double-quoted-scalar');\n      break;\n    case \"'\":\n      setFlowScalarValue(token, source, 'single-quoted-scalar');\n      break;\n    default:\n      setFlowScalarValue(token, source, 'scalar');\n  }\n}\nfunction setBlockScalarValue(token, source) {\n  const he = source.indexOf('\\n');\n  const head = source.substring(0, he);\n  const body = source.substring(he + 1) + '\\n';\n  if (token.type === 'block-scalar') {\n    const header = token.props[0];\n    if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');\n    header.source = head;\n    token.source = body;\n  } else {\n    const offset = token.offset;\n    const indent = 'indent' in token ? token.indent : -1;\n    const props = [{\n      type: 'block-scalar-header',\n      offset,\n      indent,\n      source: head\n    }];\n    if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined)) props.push({\n      type: 'newline',\n      offset: -1,\n      indent,\n      source: '\\n'\n    });\n    for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];\n    Object.assign(token, {\n      type: 'block-scalar',\n      indent,\n      props,\n      source: body\n    });\n  }\n}\n/** @returns `true` if last token is a newline */\nfunction addEndtoBlockProps(props, end) {\n  if (end) for (const st of end) switch (st.type) {\n    case 'space':\n    case 'comment':\n      props.push(st);\n      break;\n    case 'newline':\n      props.push(st);\n      return true;\n  }\n  return false;\n}\nfunction setFlowScalarValue(token, source, type) {\n  switch (token.type) {\n    case 'scalar':\n    case 'double-quoted-scalar':\n    case 'single-quoted-scalar':\n      token.type = type;\n      token.source = source;\n      break;\n    case 'block-scalar':\n      {\n        const end = token.props.slice(1);\n        let oa = source.length;\n        if (token.props[0].type === 'block-scalar-header') oa -= token.props[0].source.length;\n        for (const tok of end) tok.offset += oa;\n        delete token.props;\n        Object.assign(token, {\n          type,\n          source,\n          end\n        });\n        break;\n      }\n    case 'block-map':\n    case 'block-seq':\n      {\n        const offset = token.offset + source.length;\n        const nl = {\n          type: 'newline',\n          offset,\n          indent: token.indent,\n          source: '\\n'\n        };\n        delete token.items;\n        Object.assign(token, {\n          type,\n          source,\n          end: [nl]\n        });\n        break;\n      }\n    default:\n      {\n        const indent = 'indent' in token ? token.indent : -1;\n        const end = 'end' in token && Array.isArray(token.end) ? token.end.filter(st => st.type === 'space' || st.type === 'comment' || st.type === 'newline') : [];\n        for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];\n        Object.assign(token, {\n          type,\n          indent,\n          source,\n          end\n        });\n      }\n  }\n}\nexport { createScalarToken, resolveAsScalar, setScalarValue };","map":null,"metadata":{},"sourceType":"module"}