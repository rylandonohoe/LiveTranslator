{"ast":null,"code":"exports.get = function (belowFn) {\n  var oldLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = Infinity;\n  var dummyObject = {};\n  var v8Handler = Error.prepareStackTrace;\n  Error.prepareStackTrace = function (dummyObject, v8StackTrace) {\n    return v8StackTrace;\n  };\n  Error.captureStackTrace(dummyObject, belowFn || exports.get);\n  var v8StackTrace = dummyObject.stack;\n  Error.prepareStackTrace = v8Handler;\n  Error.stackTraceLimit = oldLimit;\n  return v8StackTrace;\n};\nexports.parse = function (err) {\n  if (!err.stack) {\n    return [];\n  }\n  var self = this;\n  var lines = err.stack.split('\\n').slice(1);\n  return lines.map(function (line) {\n    if (line.match(/^\\s*[-]{4,}$/)) {\n      return self._createParsedCallSite({\n        fileName: line,\n        lineNumber: null,\n        functionName: null,\n        typeName: null,\n        methodName: null,\n        columnNumber: null,\n        'native': null\n      });\n    }\n    var lineMatch = line.match(/at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/);\n    if (!lineMatch) {\n      return;\n    }\n    var object = null;\n    var method = null;\n    var functionName = null;\n    var typeName = null;\n    var methodName = null;\n    var isNative = lineMatch[5] === 'native';\n    if (lineMatch[1]) {\n      functionName = lineMatch[1];\n      var methodStart = functionName.lastIndexOf('.');\n      if (functionName[methodStart - 1] == '.') methodStart--;\n      if (methodStart > 0) {\n        object = functionName.substr(0, methodStart);\n        method = functionName.substr(methodStart + 1);\n        var objectEnd = object.indexOf('.Module');\n        if (objectEnd > 0) {\n          functionName = functionName.substr(objectEnd + 1);\n          object = object.substr(0, objectEnd);\n        }\n      }\n      typeName = null;\n    }\n    if (method) {\n      typeName = object;\n      methodName = method;\n    }\n    if (method === '<anonymous>') {\n      methodName = null;\n      functionName = null;\n    }\n    var properties = {\n      fileName: lineMatch[2] || null,\n      lineNumber: parseInt(lineMatch[3], 10) || null,\n      functionName: functionName,\n      typeName: typeName,\n      methodName: methodName,\n      columnNumber: parseInt(lineMatch[4], 10) || null,\n      'native': isNative\n    };\n    return self._createParsedCallSite(properties);\n  }).filter(function (callSite) {\n    return !!callSite;\n  });\n};\nfunction CallSite(properties) {\n  for (var property in properties) {\n    this[property] = properties[property];\n  }\n}\nvar strProperties = ['this', 'typeName', 'functionName', 'methodName', 'fileName', 'lineNumber', 'columnNumber', 'function', 'evalOrigin'];\nvar boolProperties = ['topLevel', 'eval', 'native', 'constructor'];\nstrProperties.forEach(function (property) {\n  CallSite.prototype[property] = null;\n  CallSite.prototype['get' + property[0].toUpperCase() + property.substr(1)] = function () {\n    return this[property];\n  };\n});\nboolProperties.forEach(function (property) {\n  CallSite.prototype[property] = false;\n  CallSite.prototype['is' + property[0].toUpperCase() + property.substr(1)] = function () {\n    return this[property];\n  };\n});\nexports._createParsedCallSite = function (properties) {\n  return new CallSite(properties);\n};","map":null,"metadata":{},"sourceType":"script"}