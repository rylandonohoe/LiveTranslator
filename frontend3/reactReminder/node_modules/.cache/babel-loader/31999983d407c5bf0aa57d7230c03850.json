{"ast":null,"code":"var fs = require('fs');\nvar utf8 = require('./encoding/utf8'),\n  unicode = require('./encoding/unicode'),\n  mbcs = require('./encoding/mbcs'),\n  sbcs = require('./encoding/sbcs'),\n  iso2022 = require('./encoding/iso2022');\nvar self = this;\nvar recognisers = [new utf8(), new unicode.UTF_16BE(), new unicode.UTF_16LE(), new unicode.UTF_32BE(), new unicode.UTF_32LE(), new mbcs.sjis(), new mbcs.big5(), new mbcs.euc_jp(), new mbcs.euc_kr(), new mbcs.gb_18030(), new iso2022.ISO_2022_JP(), new iso2022.ISO_2022_KR(), new iso2022.ISO_2022_CN(), new sbcs.ISO_8859_1(), new sbcs.ISO_8859_2(), new sbcs.ISO_8859_5(), new sbcs.ISO_8859_6(), new sbcs.ISO_8859_7(), new sbcs.ISO_8859_8(), new sbcs.ISO_8859_9(), new sbcs.windows_1251(), new sbcs.windows_1256(), new sbcs.KOI8_R()];\nmodule.exports.detect = function (buffer, opts) {\n  // Tally up the byte occurence statistics.\n  var fByteStats = [];\n  for (var i = 0; i < 256; i++) fByteStats[i] = 0;\n  for (var i = buffer.length - 1; i >= 0; i--) fByteStats[buffer[i] & 0x00ff]++;\n  var fC1Bytes = false;\n  for (var i = 0x80; i <= 0x9F; i += 1) {\n    if (fByteStats[i] != 0) {\n      fC1Bytes = true;\n      break;\n    }\n  }\n  var context = {\n    fByteStats: fByteStats,\n    fC1Bytes: fC1Bytes,\n    fRawInput: buffer,\n    fRawLength: buffer.length,\n    fInputBytes: buffer,\n    fInputLen: buffer.length\n  };\n  var matches = recognisers.map(function (rec) {\n    return rec.match(context);\n  }).filter(function (match) {\n    return !!match;\n  }).sort(function (a, b) {\n    return b.confidence - a.confidence;\n  });\n  if (opts && opts.returnAllMatches === true) {\n    return matches;\n  } else {\n    return matches.length > 0 ? matches[0].name : null;\n  }\n};\nmodule.exports.detectFile = function (filepath, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  var fd;\n  var handler = function (err, buffer) {\n    if (fd) {\n      fs.closeSync(fd);\n    }\n    if (err) return cb(err, null);\n    cb(null, self.detect(buffer, opts));\n  };\n  if (opts && opts.sampleSize) {\n    fd = fs.openSync(filepath, 'r'), sample = Buffer.allocUnsafe(opts.sampleSize);\n    fs.read(fd, sample, 0, opts.sampleSize, null, function (err) {\n      handler(err, sample);\n    });\n    return;\n  }\n  fs.readFile(filepath, handler);\n};\nmodule.exports.detectFileSync = function (filepath, opts) {\n  if (opts && opts.sampleSize) {\n    var fd = fs.openSync(filepath, 'r'),\n      sample = Buffer.allocUnsafe(opts.sampleSize);\n    fs.readSync(fd, sample, 0, opts.sampleSize);\n    fs.closeSync(fd);\n    return self.detect(sample, opts);\n  }\n  return self.detect(fs.readFileSync(filepath), opts);\n};\n\n// Wrappers for the previous functions to return all encodings\nmodule.exports.detectAll = function (buffer, opts) {\n  if (typeof opts !== 'object') {\n    opts = {};\n  }\n  opts.returnAllMatches = true;\n  return self.detect(buffer, opts);\n};\nmodule.exports.detectFileAll = function (filepath, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  if (typeof opts !== 'object') {\n    opts = {};\n  }\n  opts.returnAllMatches = true;\n  self.detectFile(filepath, opts, cb);\n};\nmodule.exports.detectFileAllSync = function (filepath, opts) {\n  if (typeof opts !== 'object') {\n    opts = {};\n  }\n  opts.returnAllMatches = true;\n  return self.detectFileSync(filepath, opts);\n};","map":null,"metadata":{},"sourceType":"script"}