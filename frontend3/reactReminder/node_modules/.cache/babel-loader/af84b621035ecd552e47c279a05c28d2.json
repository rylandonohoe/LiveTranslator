{"ast":null,"code":"/**\n * Stringify a CST document, token, or collection item\n *\n * Fair warning: This applies no validation whatsoever, and\n * simply concatenates the sources in their logical order.\n */\nconst stringify = cst => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);\nfunction stringifyToken(token) {\n  switch (token.type) {\n    case 'block-scalar':\n      {\n        let res = '';\n        for (const tok of token.props) res += stringifyToken(tok);\n        return res + token.source;\n      }\n    case 'block-map':\n    case 'block-seq':\n      {\n        let res = '';\n        for (const item of token.items) res += stringifyItem(item);\n        return res;\n      }\n    case 'flow-collection':\n      {\n        let res = token.start.source;\n        for (const item of token.items) res += stringifyItem(item);\n        for (const st of token.end) res += st.source;\n        return res;\n      }\n    case 'document':\n      {\n        let res = stringifyItem(token);\n        if (token.end) for (const st of token.end) res += st.source;\n        return res;\n      }\n    default:\n      {\n        let res = token.source;\n        if ('end' in token && token.end) for (const st of token.end) res += st.source;\n        return res;\n      }\n  }\n}\nfunction stringifyItem({\n  start,\n  key,\n  sep,\n  value\n}) {\n  let res = '';\n  for (const st of start) res += st.source;\n  if (key) res += stringifyToken(key);\n  if (sep) for (const st of sep) res += st.source;\n  if (value) res += stringifyToken(value);\n  return res;\n}\nexport { stringify };","map":null,"metadata":{},"sourceType":"module"}