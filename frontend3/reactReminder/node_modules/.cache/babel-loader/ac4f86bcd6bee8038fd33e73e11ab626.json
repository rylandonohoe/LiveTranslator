{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/rianadutta/Downloads/mchacks12/LiveTranslator/frontend3/reactReminder/node_modules/@babel/runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.openInBrowser = exports.connectableHostname = exports.randomInt = exports.debounce = exports.last = exports.cloneDeep = exports.groupBy = exports.assertIsStringOrUndefined = exports.assertIsNumber = exports.assertIsString = exports.thirtyDaysFromNow = exports.isRunningInWSL = exports.isCloudEnvironment = exports.datetimeString = exports.createDestroyer = exports.sleep = exports.promiseWithSpinner = exports.setupLoggers = exports.tryParse = exports.tryStringify = exports.promiseProps = exports.withTimeout = exports.promiseWhile = exports.promiseAllSettled = exports.getFunctionsEventProvider = exports.endpoint = exports.makeActiveProject = exports.streamToString = exports.stringToStream = exports.explainStdin = exports.allSettled = exports.reject = exports.logLabeledError = exports.logLabeledWarning = exports.logWarning = exports.logLabeledBullet = exports.logBullet = exports.logLabeledSuccess = exports.logSuccess = exports.addSubdomain = exports.addDatabaseNamespace = exports.getDatabaseViewDataUrl = exports.getDatabaseUrl = exports.envOverride = exports.setVSCodeEnvVars = exports.getInheritedOption = exports.consoleUrl = exports.vscodeEnvVars = exports.envOverrides = exports.IS_WINDOWS = void 0;\nexports.updateOrCreateGitignore = exports.readSecretValue = exports.generateId = exports.wrappedSafeLoad = exports.readFileFromDirectory = exports.getHostnameFromUrl = exports.openInBrowserPopup = void 0;\nconst fs = require(\"fs-extra\");\nconst tty = require(\"tty\");\nconst path = require(\"node:path\");\nconst yaml = require(\"yaml\");\nconst _ = require(\"lodash\");\nconst url = require(\"url\");\nconst http = require(\"http\");\nconst clc = require(\"colorette\");\nconst open = require(\"open\");\nconst ora = require(\"ora\");\nconst process = require(\"process\");\nconst stream_1 = require(\"stream\");\nconst winston = require(\"winston\");\nconst triple_beam_1 = require(\"triple-beam\");\nconst assert_1 = require(\"assert\");\nconst node_util_1 = require(\"node:util\");\nconst portfinder_1 = require(\"portfinder\");\nconst configstore_1 = require(\"./configstore\");\nconst error_1 = require(\"./error\");\nconst logger_1 = require(\"./logger\");\nconst prompt_1 = require(\"./prompt\");\nconst templates_1 = require(\"./templates\");\nconst vsCodeUtils_1 = require(\"./vsCodeUtils\");\nexports.IS_WINDOWS = process.platform === \"win32\";\nconst SUCCESS_CHAR = exports.IS_WINDOWS ? \"+\" : \"✔\";\nconst WARNING_CHAR = exports.IS_WINDOWS ? \"!\" : \"⚠\";\nconst ERROR_CHAR = exports.IS_WINDOWS ? \"!!\" : \"⬢\";\nconst THIRTY_DAYS_IN_MILLISECONDS = 30 * 24 * 60 * 60 * 1000;\nexports.envOverrides = [];\nexports.vscodeEnvVars = {};\nfunction consoleUrl(project, path) {\n  const api = require(\"./api\");\n  return \"\".concat(api.consoleOrigin(), \"/project/\").concat(project).concat(path);\n}\nexports.consoleUrl = consoleUrl;\nfunction getInheritedOption(options, key) {\n  let target = options;\n  while (target) {\n    if (target[key] !== undefined) {\n      return target[key];\n    }\n    target = target.parent;\n  }\n}\nexports.getInheritedOption = getInheritedOption;\nfunction setVSCodeEnvVars(envVar, value) {\n  exports.vscodeEnvVars[envVar] = value;\n}\nexports.setVSCodeEnvVars = setVSCodeEnvVars;\nfunction envOverride(envname, value, coerce) {\n  const currentEnvValue = (0, vsCodeUtils_1.isVSCodeExtension)() && exports.vscodeEnvVars[envname] ? exports.vscodeEnvVars[envname] : process.env[envname];\n  if (currentEnvValue && currentEnvValue.length) {\n    exports.envOverrides.push(envname);\n    if (coerce) {\n      try {\n        return coerce(currentEnvValue, value);\n      } catch (e) {\n        return value;\n      }\n    }\n    return currentEnvValue;\n  }\n  return value;\n}\nexports.envOverride = envOverride;\nfunction getDatabaseUrl(origin, namespace, pathname) {\n  const withPath = url.resolve(origin, pathname);\n  return addDatabaseNamespace(withPath, namespace);\n}\nexports.getDatabaseUrl = getDatabaseUrl;\nfunction getDatabaseViewDataUrl(origin, project, namespace, pathname) {\n  const urlObj = new url.URL(origin);\n  if (urlObj.hostname.includes(\"firebaseio\") || urlObj.hostname.includes(\"firebasedatabase\")) {\n    return consoleUrl(project, \"/database/\".concat(namespace, \"/data\").concat(pathname));\n  }\n  return getDatabaseUrl(origin, namespace, pathname + \".json\");\n}\nexports.getDatabaseViewDataUrl = getDatabaseViewDataUrl;\nfunction addDatabaseNamespace(origin, namespace) {\n  const urlObj = new url.URL(origin);\n  if (urlObj.hostname.includes(namespace)) {\n    return urlObj.href;\n  }\n  if (urlObj.hostname.includes(\"firebaseio\") || urlObj.hostname.includes(\"firebasedatabase\")) {\n    return addSubdomain(origin, namespace);\n  }\n  urlObj.searchParams.set(\"ns\", namespace);\n  return urlObj.href;\n}\nexports.addDatabaseNamespace = addDatabaseNamespace;\nfunction addSubdomain(origin, subdomain) {\n  return origin.replace(\"//\", \"//\".concat(subdomain, \".\"));\n}\nexports.addSubdomain = addSubdomain;\nfunction logSuccess(message, type = \"info\", data = undefined) {\n  logger_1.logger[type](clc.green(clc.bold(\"\".concat(SUCCESS_CHAR, \" \"))), message, data);\n}\nexports.logSuccess = logSuccess;\nfunction logLabeledSuccess(label, message, type = \"info\", data = undefined) {\n  logger_1.logger[type](clc.green(clc.bold(\"\".concat(SUCCESS_CHAR, \"  \").concat(label, \":\"))), message, data);\n}\nexports.logLabeledSuccess = logLabeledSuccess;\nfunction logBullet(message, type = \"info\", data = undefined) {\n  logger_1.logger[type](clc.cyan(clc.bold(\"i \")), message, data);\n}\nexports.logBullet = logBullet;\nfunction logLabeledBullet(label, message, type = \"info\", data = undefined) {\n  logger_1.logger[type](clc.cyan(clc.bold(\"i  \".concat(label, \":\"))), message, data);\n}\nexports.logLabeledBullet = logLabeledBullet;\nfunction logWarning(message, type = \"warn\", data = undefined) {\n  logger_1.logger[type](clc.yellow(clc.bold(\"\".concat(WARNING_CHAR, \" \"))), message, data);\n}\nexports.logWarning = logWarning;\nfunction logLabeledWarning(label, message, type = \"warn\", data = undefined) {\n  logger_1.logger[type](clc.yellow(clc.bold(\"\".concat(WARNING_CHAR, \"  \").concat(label, \":\"))), message, data);\n}\nexports.logLabeledWarning = logLabeledWarning;\nfunction logLabeledError(label, message, type = \"error\", data = undefined) {\n  logger_1.logger[type](clc.red(clc.bold(\"\".concat(ERROR_CHAR, \"  \").concat(label, \":\"))), message, data);\n}\nexports.logLabeledError = logLabeledError;\nfunction reject(message, options) {\n  return Promise.reject(new error_1.FirebaseError(message, options));\n}\nexports.reject = reject;\nfunction allSettled(promises) {\n  if (!promises.length) {\n    return Promise.resolve([]);\n  }\n  return new Promise(resolve => {\n    let remaining = promises.length;\n    const results = [];\n    for (let i = 0; i < promises.length; i++) {\n      void Promise.resolve(promises[i]).then(result => {\n        results[i] = {\n          status: \"fulfilled\",\n          value: result\n        };\n      }, err => {\n        results[i] = {\n          status: \"rejected\",\n          reason: err\n        };\n      }).then(() => {\n        if (! --remaining) {\n          resolve(results);\n        }\n      });\n    }\n  });\n}\nexports.allSettled = allSettled;\nfunction explainStdin() {\n  if (exports.IS_WINDOWS) {\n    throw new error_1.FirebaseError(\"STDIN input is not available on Windows.\", {\n      exit: 1\n    });\n  }\n  if (process.stdin.isTTY) {\n    logger_1.logger.info(clc.bold(\"Note:\"), \"Reading STDIN. Type JSON data and then press Ctrl-D\");\n  }\n}\nexports.explainStdin = explainStdin;\nfunction stringToStream(text) {\n  if (!text) {\n    return undefined;\n  }\n  const s = new stream_1.Readable();\n  s.push(text);\n  s.push(null);\n  return s;\n}\nexports.stringToStream = stringToStream;\nfunction streamToString(s) {\n  return new Promise((resolve, reject) => {\n    let b = \"\";\n    s.on(\"error\", reject);\n    s.on(\"data\", d => b += \"\".concat(d));\n    s.once(\"end\", () => resolve(b));\n  });\n}\nexports.streamToString = streamToString;\nfunction makeActiveProject(projectDir, newActive) {\n  const activeProjects = configstore_1.configstore.get(\"activeProjects\") || {};\n  if (newActive) {\n    activeProjects[projectDir] = newActive;\n  } else {\n    _.unset(activeProjects, projectDir);\n  }\n  configstore_1.configstore.set(\"activeProjects\", activeProjects);\n}\nexports.makeActiveProject = makeActiveProject;\nfunction endpoint(parts) {\n  return \"/\".concat(parts.join(\"/\"));\n}\nexports.endpoint = endpoint;\nfunction getFunctionsEventProvider(eventType) {\n  const parts = eventType.split(\"/\");\n  if (parts.length > 1) {\n    const provider = last(parts[1].split(\".\"));\n    return _.capitalize(provider);\n  }\n  if (/google.*pubsub/.exec(eventType)) {\n    return \"PubSub\";\n  } else if (/google.storage/.exec(eventType)) {\n    return \"Storage\";\n  } else if (/google.analytics/.exec(eventType)) {\n    return \"Analytics\";\n  } else if (/google.firebase.database/.exec(eventType)) {\n    return \"Database\";\n  } else if (/google.firebase.auth/.exec(eventType)) {\n    return \"Auth\";\n  } else if (/google.firebase.crashlytics/.exec(eventType)) {\n    return \"Crashlytics\";\n  } else if (/google.*firestore/.exec(eventType)) {\n    return \"Firestore\";\n  }\n  return _.capitalize(eventType.split(\".\")[1]);\n}\nexports.getFunctionsEventProvider = getFunctionsEventProvider;\nfunction promiseAllSettled(promises) {\n  const wrappedPromises = promises.map(async p => {\n    try {\n      const val = await Promise.resolve(p);\n      return {\n        state: \"fulfilled\",\n        value: val\n      };\n    } catch (err) {\n      return {\n        state: \"rejected\",\n        reason: err\n      };\n    }\n  });\n  return Promise.all(wrappedPromises);\n}\nexports.promiseAllSettled = promiseAllSettled;\nasync function promiseWhile(action, check, interval = 2500) {\n  return new Promise((resolve, promiseReject) => {\n    const run = async () => {\n      try {\n        const res = await action();\n        if (check(res)) {\n          return resolve(res);\n        }\n        setTimeout(run, interval);\n      } catch (err) {\n        return promiseReject(err);\n      }\n    };\n    run();\n  });\n}\nexports.promiseWhile = promiseWhile;\nfunction withTimeout(timeoutMs, promise) {\n  return new Promise((resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error(\"Timed out.\")), timeoutMs);\n    promise.then(value => {\n      clearTimeout(timeout);\n      resolve(value);\n    }, err => {\n      clearTimeout(timeout);\n      reject(err);\n    });\n  });\n}\nexports.withTimeout = withTimeout;\nasync function promiseProps(obj) {\n  const resultObj = {};\n  const promises = Object.keys(obj).map(async key => {\n    const r = await Promise.resolve(obj[key]);\n    resultObj[key] = r;\n  });\n  return Promise.all(promises).then(() => resultObj);\n}\nexports.promiseProps = promiseProps;\nfunction tryStringify(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  try {\n    return JSON.stringify(value);\n  } catch (_a) {\n    return value;\n  }\n}\nexports.tryStringify = tryStringify;\nfunction tryParse(value) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  try {\n    return JSON.parse(value);\n  } catch (_a) {\n    return value;\n  }\n}\nexports.tryParse = tryParse;\nfunction setupLoggers() {\n  if (process.env.DEBUG) {\n    logger_1.logger.add(new winston.transports.Console({\n      level: \"debug\",\n      format: winston.format.printf(info => {\n        const segments = [info.message, ...(info[triple_beam_1.SPLAT] || [])].map(tryStringify);\n        return \"\".concat((0, node_util_1.stripVTControlCharacters)(segments.join(\" \")));\n      })\n    }));\n  } else if (process.env.IS_FIREBASE_CLI) {\n    logger_1.logger.add(new winston.transports.Console({\n      level: \"info\",\n      format: winston.format.printf(info => [info.message, ...(info[triple_beam_1.SPLAT] || [])].filter(chunk => typeof chunk === \"string\").join(\" \"))\n    }));\n  }\n}\nexports.setupLoggers = setupLoggers;\nasync function promiseWithSpinner(action, message) {\n  const spinner = ora(message).start();\n  let data;\n  try {\n    data = await action();\n    spinner.succeed();\n  } catch (err) {\n    spinner.fail();\n    throw err;\n  }\n  return data;\n}\nexports.promiseWithSpinner = promiseWithSpinner;\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\nexports.sleep = sleep;\nfunction createDestroyer(server) {\n  const connections = new Set();\n  server.on(\"connection\", conn => {\n    connections.add(conn);\n    conn.once(\"close\", () => connections.delete(conn));\n  });\n  let destroyPromise = undefined;\n  return function destroyer() {\n    if (!destroyPromise) {\n      destroyPromise = new Promise((resolve, reject) => {\n        server.close(err => {\n          if (err) return reject(err);\n          resolve();\n        });\n        connections.forEach(socket => socket.destroy());\n      });\n    }\n    return destroyPromise;\n  };\n}\nexports.createDestroyer = createDestroyer;\nfunction datetimeString(d) {\n  const day = \"\".concat(d.getFullYear(), \"-\").concat((d.getMonth() + 1).toString().padStart(2, \"0\"), \"-\").concat(d.getDate().toString().padStart(2, \"0\"));\n  const time = \"\".concat(d.getHours().toString().padStart(2, \"0\"), \":\").concat(d.getMinutes().toString().padStart(2, \"0\"), \":\").concat(d.getSeconds().toString().padStart(2, \"0\"));\n  return \"\".concat(day, \" \").concat(time);\n}\nexports.datetimeString = datetimeString;\nfunction isCloudEnvironment() {\n  return !!process.env.CODESPACES || !!process.env.GOOGLE_CLOUD_WORKSTATIONS;\n}\nexports.isCloudEnvironment = isCloudEnvironment;\nfunction isRunningInWSL() {\n  return !!process.env.WSL_DISTRO_NAME;\n}\nexports.isRunningInWSL = isRunningInWSL;\nfunction thirtyDaysFromNow() {\n  return new Date(Date.now() + THIRTY_DAYS_IN_MILLISECONDS);\n}\nexports.thirtyDaysFromNow = thirtyDaysFromNow;\nfunction assertIsString(val, message) {\n  if (typeof val !== \"string\") {\n    throw new assert_1.AssertionError({\n      message: message || \"expected \\\"string\\\" but got \\\"\".concat(typeof val, \"\\\"\")\n    });\n  }\n}\nexports.assertIsString = assertIsString;\nfunction assertIsNumber(val, message) {\n  if (typeof val !== \"number\") {\n    throw new assert_1.AssertionError({\n      message: message || \"expected \\\"number\\\" but got \\\"\".concat(typeof val, \"\\\"\")\n    });\n  }\n}\nexports.assertIsNumber = assertIsNumber;\nfunction assertIsStringOrUndefined(val, message) {\n  if (!(val === undefined || typeof val === \"string\")) {\n    throw new assert_1.AssertionError({\n      message: message || \"expected \\\"string\\\" or \\\"undefined\\\" but got \\\"\".concat(typeof val, \"\\\"\")\n    });\n  }\n}\nexports.assertIsStringOrUndefined = assertIsStringOrUndefined;\nfunction groupBy(arr, f) {\n  return arr.reduce((result, item) => {\n    const key = f(item);\n    if (result[key]) {\n      result[key].push(item);\n    } else {\n      result[key] = [item];\n    }\n    return result;\n  }, {});\n}\nexports.groupBy = groupBy;\nfunction cloneArray(arr) {\n  return arr.map(e => cloneDeep(e));\n}\nfunction cloneObject(obj) {\n  const clone = {};\n  for (const _ref of Object.entries(obj)) {\n    var _ref2 = _slicedToArray(_ref, 2);\n    const k = _ref2[0];\n    const v = _ref2[1];\n    clone[k] = cloneDeep(v);\n  }\n  return clone;\n}\nfunction cloneDeep(obj) {\n  if (typeof obj !== \"object\" || !obj) {\n    return obj;\n  }\n  if (obj instanceof RegExp) {\n    return RegExp(obj, obj.flags);\n  }\n  if (obj instanceof Date) {\n    return new Date(obj);\n  }\n  if (Array.isArray(obj)) {\n    return cloneArray(obj);\n  }\n  if (obj instanceof Map) {\n    return new Map(obj.entries());\n  }\n  return cloneObject(obj);\n}\nexports.cloneDeep = cloneDeep;\nfunction last(arr) {\n  if (!Array.isArray(arr)) {\n    return undefined;\n  }\n  return arr[arr.length - 1];\n}\nexports.last = last;\nfunction debounce(fn, delay, {\n  leading\n} = {}) {\n  let timer;\n  return (...args) => {\n    if (!timer && leading) {\n      fn(...args);\n    }\n    clearTimeout(timer);\n    timer = setTimeout(() => fn(...args), delay);\n  };\n}\nexports.debounce = debounce;\nfunction randomInt(min, max) {\n  min = Math.floor(min);\n  max = Math.ceil(max) + 1;\n  return Math.floor(Math.random() * (max - min) + min);\n}\nexports.randomInt = randomInt;\nfunction connectableHostname(hostname) {\n  if (hostname === \"0.0.0.0\") {\n    hostname = \"127.0.0.1\";\n  } else if (hostname === \"::\") {\n    hostname = \"::1\";\n  } else if (hostname === \"[::]\") {\n    hostname = \"[::1]\";\n  }\n  return hostname;\n}\nexports.connectableHostname = connectableHostname;\nasync function openInBrowser(url) {\n  await open(url);\n}\nexports.openInBrowser = openInBrowser;\nasync function openInBrowserPopup(url, buttonText) {\n  const popupPage = (0, templates_1.readTemplateSync)(\"popup.html\").replace(\"${url}\", url).replace(\"${buttonText}\", buttonText);\n  const port = await (0, portfinder_1.getPortPromise)();\n  const server = http.createServer((req, res) => {\n    res.writeHead(200, {\n      \"Content-Length\": popupPage.length,\n      \"Content-Type\": \"text/html\"\n    });\n    res.end(popupPage);\n    req.socket.destroy();\n  });\n  server.listen(port);\n  const popupPageUri = \"http://localhost:\".concat(port);\n  await openInBrowser(popupPageUri);\n  return {\n    url: popupPageUri,\n    cleanup: () => {\n      server.close();\n    }\n  };\n}\nexports.openInBrowserPopup = openInBrowserPopup;\nfunction getHostnameFromUrl(url) {\n  try {\n    return new URL(url).hostname;\n  } catch (e) {\n    return null;\n  }\n}\nexports.getHostnameFromUrl = getHostnameFromUrl;\nfunction readFileFromDirectory(directory, file) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(path.resolve(directory, file), \"utf8\", (err, data) => {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          return reject(new error_1.FirebaseError(\"Could not find \\\"\".concat(file, \"\\\" in \\\"\").concat(directory, \"\\\"\"), {\n            original: err\n          }));\n        }\n        reject(new error_1.FirebaseError(\"Failed to read file \\\"\".concat(file, \"\\\" in \\\"\").concat(directory, \"\\\"\"), {\n          original: err\n        }));\n      } else {\n        resolve(data);\n      }\n    });\n  }).then(source => {\n    return {\n      source,\n      sourceDirectory: directory\n    };\n  });\n}\nexports.readFileFromDirectory = readFileFromDirectory;\nfunction wrappedSafeLoad(source) {\n  try {\n    return yaml.parse(source);\n  } catch (err) {\n    throw new error_1.FirebaseError(\"YAML Error: \".concat((0, error_1.getErrMsg)(err)), {\n      original: (0, error_1.getError)(err)\n    });\n  }\n}\nexports.wrappedSafeLoad = wrappedSafeLoad;\nfunction generateId(n = 6) {\n  const letters = \"abcdefghijklmnopqrstuvwxyz\";\n  const allChars = \"01234567890-abcdefghijklmnopqrstuvwxyz\";\n  let id = letters[Math.floor(Math.random() * letters.length)];\n  for (let i = 1; i < n; i++) {\n    const idx = Math.floor(Math.random() * allChars.length);\n    id += allChars[idx];\n  }\n  return id;\n}\nexports.generateId = generateId;\nfunction readSecretValue(prompt, dataFile) {\n  if ((!dataFile || dataFile === \"-\") && tty.isatty(0)) {\n    return (0, prompt_1.promptOnce)({\n      type: \"password\",\n      message: prompt\n    });\n  }\n  let input = 0;\n  if (dataFile && dataFile !== \"-\") {\n    input = dataFile;\n  }\n  try {\n    return Promise.resolve(fs.readFileSync(input, \"utf-8\"));\n  } catch (e) {\n    if (e.code === \"ENOENT\") {\n      throw new error_1.FirebaseError(\"File not found: \".concat(input), {\n        original: e\n      });\n    }\n    throw e;\n  }\n}\nexports.readSecretValue = readSecretValue;\nfunction updateOrCreateGitignore(dirPath, entries) {\n  const gitignorePath = path.join(dirPath, \".gitignore\");\n  if (!fs.existsSync(gitignorePath)) {\n    fs.writeFileSync(gitignorePath, entries.join(\"\\n\"));\n    return;\n  }\n  let content = fs.readFileSync(gitignorePath, \"utf-8\");\n  for (const entry of entries) {\n    if (!content.includes(entry)) {\n      content += \"\\n\".concat(entry, \"\\n\");\n    }\n  }\n  fs.writeFileSync(gitignorePath, content);\n}\nexports.updateOrCreateGitignore = updateOrCreateGitignore;","map":null,"metadata":{},"sourceType":"script"}