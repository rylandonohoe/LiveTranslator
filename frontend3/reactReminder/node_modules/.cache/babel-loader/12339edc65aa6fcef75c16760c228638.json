{"ast":null,"code":"'use strict';\n\nconst _ = {\n  isPlainObject: require('lodash/isPlainObject'),\n  get: require('lodash/get'),\n  set: require('lodash/set')\n};\nconst _require = require('rxjs'),\n  defer = _require.defer,\n  empty = _require.empty,\n  from = _require.from,\n  of = _require.of;\nconst _require2 = require('rxjs/operators'),\n  concatMap = _require2.concatMap,\n  filter = _require2.filter,\n  publish = _require2.publish,\n  reduce = _require2.reduce;\nconst runAsync = require('run-async');\nconst utils = require('../utils/utils');\nconst Base = require('./baseUI');\n\n/**\n * Base interface class other can inherits from\n */\n\nclass PromptUI extends Base {\n  constructor(prompts, opt) {\n    super(opt);\n    this.prompts = prompts;\n  }\n  run(questions, answers) {\n    // Keep global reference to the answers\n    if (_.isPlainObject(answers)) {\n      this.answers = {\n        ...answers\n      };\n    } else {\n      this.answers = {};\n    }\n\n    // Make sure questions is an array.\n    if (_.isPlainObject(questions)) {\n      // It's either an object of questions or a single question\n      questions = Object.values(questions).every(v => _.isPlainObject(v) && v.name === undefined) ? Object.entries(questions).map(([name, question]) => ({\n        name,\n        ...question\n      })) : [questions];\n    }\n\n    // Create an observable, unless we received one as parameter.\n    // Note: As this is a public interface, we cannot do an instanceof check as we won't\n    // be using the exact same object in memory.\n    const obs = Array.isArray(questions) ? from(questions) : questions;\n    this.process = obs.pipe(concatMap(this.processQuestion.bind(this)), publish() // Creates a hot Observable. It prevents duplicating prompts.\n    );\n    this.process.connect();\n    return this.process.pipe(reduce((answers, answer) => {\n      _.set(answers, answer.name, answer.answer);\n      return answers;\n    }, this.answers)).toPromise(Promise).then(this.onCompletion.bind(this), this.onError.bind(this));\n  }\n\n  /**\n   * Once all prompt are over\n   */\n\n  onCompletion() {\n    this.close();\n    return this.answers;\n  }\n  onError(error) {\n    this.close();\n    return Promise.reject(error);\n  }\n  processQuestion(question) {\n    question = {\n      ...question\n    };\n    return defer(() => {\n      const obs = of(question);\n      return obs.pipe(concatMap(this.setDefaultType.bind(this)), concatMap(this.filterIfRunnable.bind(this)), concatMap(() => utils.fetchAsyncQuestionProperty(question, 'message', this.answers)), concatMap(() => utils.fetchAsyncQuestionProperty(question, 'default', this.answers)), concatMap(() => utils.fetchAsyncQuestionProperty(question, 'choices', this.answers)), concatMap(this.fetchAnswer.bind(this)));\n    });\n  }\n  fetchAnswer(question) {\n    const Prompt = this.prompts[question.type];\n    this.activePrompt = new Prompt(question, this.rl, this.answers);\n    return defer(() => from(this.activePrompt.run().then(answer => ({\n      name: question.name,\n      answer\n    }))));\n  }\n  setDefaultType(question) {\n    // Default type to input\n    if (!this.prompts[question.type]) {\n      question.type = 'input';\n    }\n    return defer(() => of(question));\n  }\n  filterIfRunnable(question) {\n    if (question.askAnswered !== true && _.get(this.answers, question.name) !== undefined) {\n      return empty();\n    }\n    if (question.when === false) {\n      return empty();\n    }\n    if (typeof question.when !== 'function') {\n      return of(question);\n    }\n    const answers = this.answers;\n    return defer(() => from(runAsync(question.when)(answers).then(shouldRun => {\n      if (shouldRun) {\n        return question;\n      }\n    })).pipe(filter(val => val != null)));\n  }\n}\nmodule.exports = PromptUI;","map":null,"metadata":{},"sourceType":"script"}