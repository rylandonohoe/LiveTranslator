{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst mkdirsSync = require('../mkdirs').mkdirsSync;\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync;\nconst stat = require('../util/stat');\nfunction copySync(src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n  opts = opts || {};\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true; // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber; // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0002');\n  }\n  const _stat$checkPathsSync = stat.checkPathsSync(src, dest, 'copy', opts),\n    srcStat = _stat$checkPathsSync.srcStat,\n    destStat = _stat$checkPathsSync.destStat;\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy');\n  return handleFilterAndCopy(destStat, src, dest, opts);\n}\nfunction handleFilterAndCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent);\n  return getStats(destStat, src, dest, opts);\n}\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return;\n  return getStats(destStat, src, dest, opts);\n}\nfunction getStats(destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;\n  const srcStat = statSync(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);else if (srcStat.isSocket()) throw new Error(\"Cannot copy a socket file: \".concat(src));else if (srcStat.isFIFO()) throw new Error(\"Cannot copy a FIFO pipe: \".concat(src));\n  throw new Error(\"Unknown file: \".concat(src));\n}\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n  return mayCopyFile(srcStat, src, dest, opts);\n}\nfunction mayCopyFile(srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest);\n    return copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new Error(\"'\".concat(dest, \"' already exists\"));\n  }\n}\nfunction copyFile(srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest);\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);\n  return setDestMode(dest, srcStat.mode);\n}\nfunction handleTimestamps(srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);\n  return setDestTimestamps(src, dest);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200);\n}\nfunction setDestMode(dest, srcMode) {\n  return fs.chmodSync(dest, srcMode);\n}\nfunction setDestTimestamps(src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src);\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  return copyDir(src, dest, opts);\n}\nfunction mkDirAndCopy(srcMode, src, dest, opts) {\n  fs.mkdirSync(dest);\n  copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}\nfunction copyDir(src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));\n}\nfunction copyDirItem(item, src, dest, opts) {\n  const srcItem = path.join(src, item);\n  const destItem = path.join(dest, item);\n  const _stat$checkPathsSync2 = stat.checkPathsSync(srcItem, destItem, 'copy', opts),\n    destStat = _stat$checkPathsSync2.destStat;\n  return startCopy(destStat, srcItem, destItem, opts);\n}\nfunction onLink(destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src);\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest);\n  } else {\n    let resolvedDest;\n    try {\n      resolvedDest = fs.readlinkSync(dest);\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);\n      throw err;\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest);\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(\"Cannot copy '\".concat(resolvedSrc, \"' to a subdirectory of itself, '\").concat(resolvedDest, \"'.\"));\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(\"Cannot overwrite '\".concat(resolvedDest, \"' with '\").concat(resolvedSrc, \"'.\"));\n    }\n    return copyLink(resolvedSrc, dest);\n  }\n}\nfunction copyLink(resolvedSrc, dest) {\n  fs.unlinkSync(dest);\n  return fs.symlinkSync(resolvedSrc, dest);\n}\nmodule.exports = copySync;","map":null,"metadata":{},"sourceType":"script"}