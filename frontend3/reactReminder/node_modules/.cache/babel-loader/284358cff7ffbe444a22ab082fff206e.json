{"ast":null,"code":"'use strict';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst stringify = configure();\n\n// @ts-expect-error\nstringify.configure = configure;\n// @ts-expect-error\nstringify.stringify = stringify;\n\n// @ts-expect-error\nstringify.default = stringify;\n\n// @ts-expect-error used for named export\nexports.stringify = stringify;\n// @ts-expect-error used for named export\nexports.configure = configure;\nmodule.exports = stringify;\n\n// eslint-disable-next-line no-control-regex\nconst strEscapeSequencesRegExp = /[\\u0000-\\u001f\\u0022\\u005c\\ud800-\\udfff]/;\n\n// Escape C0 control characters, double quotes, the backslash and every code\n// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.\nfunction strEscape(str) {\n  // Some magic numbers that worked out fine while benchmarking with v8 8.0\n  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {\n    return \"\\\"\".concat(str, \"\\\"\");\n  }\n  return JSON.stringify(str);\n}\nfunction sort(array, comparator) {\n  // Insertion sort is very efficient for small input sizes, but it has a bad\n  // worst case complexity. Thus, use native array sort for bigger values.\n  if (array.length > 2e2 || comparator) {\n    return array.sort(comparator);\n  }\n  for (let i = 1; i < array.length; i++) {\n    const currentValue = array[i];\n    let position = i;\n    while (position !== 0 && array[position - 1] > currentValue) {\n      array[position] = array[position - 1];\n      position--;\n    }\n    array[position] = currentValue;\n  }\n  return array;\n}\nconst typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;\nfunction isTypedArrayWithEntries(value) {\n  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;\n}\nfunction stringifyTypedArray(array, separator, maximumBreadth) {\n  if (array.length < maximumBreadth) {\n    maximumBreadth = array.length;\n  }\n  const whitespace = separator === ',' ? '' : ' ';\n  let res = \"\\\"0\\\":\".concat(whitespace).concat(array[0]);\n  for (let i = 1; i < maximumBreadth; i++) {\n    res += \"\".concat(separator, \"\\\"\").concat(i, \"\\\":\").concat(whitespace).concat(array[i]);\n  }\n  return res;\n}\nfunction getCircularValueOption(options) {\n  if (hasOwnProperty.call(options, 'circularValue')) {\n    const circularValue = options.circularValue;\n    if (typeof circularValue === 'string') {\n      return \"\\\"\".concat(circularValue, \"\\\"\");\n    }\n    if (circularValue == null) {\n      return circularValue;\n    }\n    if (circularValue === Error || circularValue === TypeError) {\n      return {\n        toString() {\n          throw new TypeError('Converting circular structure to JSON');\n        }\n      };\n    }\n    throw new TypeError('The \"circularValue\" argument must be of type string or the value null or undefined');\n  }\n  return '\"[Circular]\"';\n}\nfunction getDeterministicOption(options) {\n  let value;\n  if (hasOwnProperty.call(options, 'deterministic')) {\n    value = options.deterministic;\n    if (typeof value !== 'boolean' && typeof value !== 'function') {\n      throw new TypeError('The \"deterministic\" argument must be of type boolean or comparator function');\n    }\n  }\n  return value === undefined ? true : value;\n}\nfunction getBooleanOption(options, key) {\n  let value;\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key];\n    if (typeof value !== 'boolean') {\n      throw new TypeError(\"The \\\"\".concat(key, \"\\\" argument must be of type boolean\"));\n    }\n  }\n  return value === undefined ? true : value;\n}\nfunction getPositiveIntegerOption(options, key) {\n  let value;\n  if (hasOwnProperty.call(options, key)) {\n    value = options[key];\n    if (typeof value !== 'number') {\n      throw new TypeError(\"The \\\"\".concat(key, \"\\\" argument must be of type number\"));\n    }\n    if (!Number.isInteger(value)) {\n      throw new TypeError(\"The \\\"\".concat(key, \"\\\" argument must be an integer\"));\n    }\n    if (value < 1) {\n      throw new RangeError(\"The \\\"\".concat(key, \"\\\" argument must be >= 1\"));\n    }\n  }\n  return value === undefined ? Infinity : value;\n}\nfunction getItemCount(number) {\n  if (number === 1) {\n    return '1 item';\n  }\n  return \"\".concat(number, \" items\");\n}\nfunction getUniqueReplacerSet(replacerArray) {\n  const replacerSet = new Set();\n  for (const value of replacerArray) {\n    if (typeof value === 'string' || typeof value === 'number') {\n      replacerSet.add(String(value));\n    }\n  }\n  return replacerSet;\n}\nfunction getStrictOption(options) {\n  if (hasOwnProperty.call(options, 'strict')) {\n    const value = options.strict;\n    if (typeof value !== 'boolean') {\n      throw new TypeError('The \"strict\" argument must be of type boolean');\n    }\n    if (value) {\n      return value => {\n        let message = \"Object can not safely be stringified. Received type \".concat(typeof value);\n        if (typeof value !== 'function') message += \" (\".concat(value.toString(), \")\");\n        throw new Error(message);\n      };\n    }\n  }\n}\nfunction configure(options) {\n  options = {\n    ...options\n  };\n  const fail = getStrictOption(options);\n  if (fail) {\n    if (options.bigint === undefined) {\n      options.bigint = false;\n    }\n    if (!('circularValue' in options)) {\n      options.circularValue = Error;\n    }\n  }\n  const circularValue = getCircularValueOption(options);\n  const bigint = getBooleanOption(options, 'bigint');\n  const deterministic = getDeterministicOption(options);\n  const comparator = typeof deterministic === 'function' ? deterministic : undefined;\n  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth');\n  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth');\n  function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {\n    let value = parent[key];\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key);\n    }\n    value = replacer.call(parent, key, value);\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value);\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n          let res = '';\n          let join = ',';\n          const originalIndentation = indentation;\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n            stack.push(value);\n            if (spacer !== '') {\n              indentation += spacer;\n              res += \"\\n\".concat(indentation);\n              join = \",\\n\".concat(indentation);\n            }\n            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            let i = 0;\n            for (; i < maximumValuesToStringify - 1; i++) {\n              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);\n              res += tmp !== undefined ? tmp : 'null';\n              res += join;\n            }\n            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);\n            res += tmp !== undefined ? tmp : 'null';\n            if (value.length - 1 > maximumBreadth) {\n              const removedKeys = value.length - maximumBreadth - 1;\n              res += \"\".concat(join, \"\\\"... \").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n            if (spacer !== '') {\n              res += \"\\n\".concat(originalIndentation);\n            }\n            stack.pop();\n            return \"[\".concat(res, \"]\");\n          }\n          let keys = Object.keys(value);\n          const keyLength = keys.length;\n          if (keyLength === 0) {\n            return '{}';\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Object]\"';\n          }\n          let whitespace = '';\n          let separator = '';\n          if (spacer !== '') {\n            indentation += spacer;\n            join = \",\\n\".concat(indentation);\n            whitespace = ' ';\n          }\n          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n          if (deterministic && !isTypedArrayWithEntries(value)) {\n            keys = sort(keys, comparator);\n          }\n          stack.push(value);\n          for (let i = 0; i < maximumPropertiesToStringify; i++) {\n            const key = keys[i];\n            const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation);\n            if (tmp !== undefined) {\n              res += \"\".concat(separator).concat(strEscape(key), \":\").concat(whitespace).concat(tmp);\n              separator = join;\n            }\n          }\n          if (keyLength > maximumBreadth) {\n            const removedKeys = keyLength - maximumBreadth;\n            res += \"\".concat(separator, \"\\\"...\\\":\").concat(whitespace, \"\\\"\").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            separator = join;\n          }\n          if (spacer !== '' && separator.length > 1) {\n            res = \"\\n\".concat(indentation).concat(res, \"\\n\").concat(originalIndentation);\n          }\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null';\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n      case 'undefined':\n        return undefined;\n      case 'bigint':\n        if (bigint) {\n          return String(value);\n        }\n      // fallthrough\n      default:\n        return fail ? fail(value) : undefined;\n    }\n  }\n  function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {\n    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {\n      value = value.toJSON(key);\n    }\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value);\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n          const originalIndentation = indentation;\n          let res = '';\n          let join = ',';\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n            stack.push(value);\n            if (spacer !== '') {\n              indentation += spacer;\n              res += \"\\n\".concat(indentation);\n              join = \",\\n\".concat(indentation);\n            }\n            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            let i = 0;\n            for (; i < maximumValuesToStringify - 1; i++) {\n              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);\n              res += tmp !== undefined ? tmp : 'null';\n              res += join;\n            }\n            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);\n            res += tmp !== undefined ? tmp : 'null';\n            if (value.length - 1 > maximumBreadth) {\n              const removedKeys = value.length - maximumBreadth - 1;\n              res += \"\".concat(join, \"\\\"... \").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n            if (spacer !== '') {\n              res += \"\\n\".concat(originalIndentation);\n            }\n            stack.pop();\n            return \"[\".concat(res, \"]\");\n          }\n          stack.push(value);\n          let whitespace = '';\n          if (spacer !== '') {\n            indentation += spacer;\n            join = \",\\n\".concat(indentation);\n            whitespace = ' ';\n          }\n          let separator = '';\n          for (const key of replacer) {\n            const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation);\n            if (tmp !== undefined) {\n              res += \"\".concat(separator).concat(strEscape(key), \":\").concat(whitespace).concat(tmp);\n              separator = join;\n            }\n          }\n          if (spacer !== '' && separator.length > 1) {\n            res = \"\\n\".concat(indentation).concat(res, \"\\n\").concat(originalIndentation);\n          }\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null';\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n      case 'undefined':\n        return undefined;\n      case 'bigint':\n        if (bigint) {\n          return String(value);\n        }\n      // fallthrough\n      default:\n        return fail ? fail(value) : undefined;\n    }\n  }\n  function stringifyIndent(key, value, stack, spacer, indentation) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value);\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n          if (typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n            // Prevent calling `toJSON` again.\n            if (typeof value !== 'object') {\n              return stringifyIndent(key, value, stack, spacer, indentation);\n            }\n            if (value === null) {\n              return 'null';\n            }\n          }\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n          const originalIndentation = indentation;\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n            stack.push(value);\n            indentation += spacer;\n            let res = \"\\n\".concat(indentation);\n            const join = \",\\n\".concat(indentation);\n            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            let i = 0;\n            for (; i < maximumValuesToStringify - 1; i++) {\n              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);\n              res += tmp !== undefined ? tmp : 'null';\n              res += join;\n            }\n            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);\n            res += tmp !== undefined ? tmp : 'null';\n            if (value.length - 1 > maximumBreadth) {\n              const removedKeys = value.length - maximumBreadth - 1;\n              res += \"\".concat(join, \"\\\"... \").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n            res += \"\\n\".concat(originalIndentation);\n            stack.pop();\n            return \"[\".concat(res, \"]\");\n          }\n          let keys = Object.keys(value);\n          const keyLength = keys.length;\n          if (keyLength === 0) {\n            return '{}';\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Object]\"';\n          }\n          indentation += spacer;\n          const join = \",\\n\".concat(indentation);\n          let res = '';\n          let separator = '';\n          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n          if (isTypedArrayWithEntries(value)) {\n            res += stringifyTypedArray(value, join, maximumBreadth);\n            keys = keys.slice(value.length);\n            maximumPropertiesToStringify -= value.length;\n            separator = join;\n          }\n          if (deterministic) {\n            keys = sort(keys, comparator);\n          }\n          stack.push(value);\n          for (let i = 0; i < maximumPropertiesToStringify; i++) {\n            const key = keys[i];\n            const tmp = stringifyIndent(key, value[key], stack, spacer, indentation);\n            if (tmp !== undefined) {\n              res += \"\".concat(separator).concat(strEscape(key), \": \").concat(tmp);\n              separator = join;\n            }\n          }\n          if (keyLength > maximumBreadth) {\n            const removedKeys = keyLength - maximumBreadth;\n            res += \"\".concat(separator, \"\\\"...\\\": \\\"\").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            separator = join;\n          }\n          if (separator !== '') {\n            res = \"\\n\".concat(indentation).concat(res, \"\\n\").concat(originalIndentation);\n          }\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null';\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n      case 'undefined':\n        return undefined;\n      case 'bigint':\n        if (bigint) {\n          return String(value);\n        }\n      // fallthrough\n      default:\n        return fail ? fail(value) : undefined;\n    }\n  }\n  function stringifySimple(key, value, stack) {\n    switch (typeof value) {\n      case 'string':\n        return strEscape(value);\n      case 'object':\n        {\n          if (value === null) {\n            return 'null';\n          }\n          if (typeof value.toJSON === 'function') {\n            value = value.toJSON(key);\n            // Prevent calling `toJSON` again\n            if (typeof value !== 'object') {\n              return stringifySimple(key, value, stack);\n            }\n            if (value === null) {\n              return 'null';\n            }\n          }\n          if (stack.indexOf(value) !== -1) {\n            return circularValue;\n          }\n          let res = '';\n          const hasLength = value.length !== undefined;\n          if (hasLength && Array.isArray(value)) {\n            if (value.length === 0) {\n              return '[]';\n            }\n            if (maximumDepth < stack.length + 1) {\n              return '\"[Array]\"';\n            }\n            stack.push(value);\n            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);\n            let i = 0;\n            for (; i < maximumValuesToStringify - 1; i++) {\n              const tmp = stringifySimple(String(i), value[i], stack);\n              res += tmp !== undefined ? tmp : 'null';\n              res += ',';\n            }\n            const tmp = stringifySimple(String(i), value[i], stack);\n            res += tmp !== undefined ? tmp : 'null';\n            if (value.length - 1 > maximumBreadth) {\n              const removedKeys = value.length - maximumBreadth - 1;\n              res += \",\\\"... \".concat(getItemCount(removedKeys), \" not stringified\\\"\");\n            }\n            stack.pop();\n            return \"[\".concat(res, \"]\");\n          }\n          let keys = Object.keys(value);\n          const keyLength = keys.length;\n          if (keyLength === 0) {\n            return '{}';\n          }\n          if (maximumDepth < stack.length + 1) {\n            return '\"[Object]\"';\n          }\n          let separator = '';\n          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);\n          if (hasLength && isTypedArrayWithEntries(value)) {\n            res += stringifyTypedArray(value, ',', maximumBreadth);\n            keys = keys.slice(value.length);\n            maximumPropertiesToStringify -= value.length;\n            separator = ',';\n          }\n          if (deterministic) {\n            keys = sort(keys, comparator);\n          }\n          stack.push(value);\n          for (let i = 0; i < maximumPropertiesToStringify; i++) {\n            const key = keys[i];\n            const tmp = stringifySimple(key, value[key], stack);\n            if (tmp !== undefined) {\n              res += \"\".concat(separator).concat(strEscape(key), \":\").concat(tmp);\n              separator = ',';\n            }\n          }\n          if (keyLength > maximumBreadth) {\n            const removedKeys = keyLength - maximumBreadth;\n            res += \"\".concat(separator, \"\\\"...\\\":\\\"\").concat(getItemCount(removedKeys), \" not stringified\\\"\");\n          }\n          stack.pop();\n          return \"{\".concat(res, \"}\");\n        }\n      case 'number':\n        return isFinite(value) ? String(value) : fail ? fail(value) : 'null';\n      case 'boolean':\n        return value === true ? 'true' : 'false';\n      case 'undefined':\n        return undefined;\n      case 'bigint':\n        if (bigint) {\n          return String(value);\n        }\n      // fallthrough\n      default:\n        return fail ? fail(value) : undefined;\n    }\n  }\n  function stringify(value, replacer, space) {\n    if (arguments.length > 1) {\n      let spacer = '';\n      if (typeof space === 'number') {\n        spacer = ' '.repeat(Math.min(space, 10));\n      } else if (typeof space === 'string') {\n        spacer = space.slice(0, 10);\n      }\n      if (replacer != null) {\n        if (typeof replacer === 'function') {\n          return stringifyFnReplacer('', {\n            '': value\n          }, [], replacer, spacer, '');\n        }\n        if (Array.isArray(replacer)) {\n          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '');\n        }\n      }\n      if (spacer.length !== 0) {\n        return stringifyIndent('', value, [], spacer, '');\n      }\n    }\n    return stringifySimple('', value, []);\n  }\n  return stringify;\n}","map":null,"metadata":{},"sourceType":"script"}