{"ast":null,"code":"/**\n * exception-handler.js: Object for handling uncaughtException events.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n'use strict';\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nvar os = require('os');\nvar asyncForEach = require('async/forEach');\nvar debug = require('@dabh/diagnostics')('winston:exception');\nvar once = require('one-time');\nvar stackTrace = require('stack-trace');\nvar ExceptionStream = require('./exception-stream');\n\n/**\n * Object for handling uncaughtException events.\n * @type {ExceptionHandler}\n */\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger} logger - TODO: add param description\n   */\n  function ExceptionHandler(logger) {\n    _classCallCheck(this, ExceptionHandler);\n    if (!logger) {\n      throw new Error('Logger is required to handle exceptions');\n    }\n    this.logger = logger;\n    this.handlers = new Map();\n  }\n\n  /**\n   * Handles `uncaughtException` events for the current process by adding any\n   * handlers passed in.\n   * @returns {undefined}\n   */\n  return _createClass(ExceptionHandler, [{\n    key: \"handle\",\n    value: function handle() {\n      var _this = this;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      args.forEach(function (arg) {\n        if (Array.isArray(arg)) {\n          return arg.forEach(function (handler) {\n            return _this._addHandler(handler);\n          });\n        }\n        _this._addHandler(arg);\n      });\n      if (!this.catcher) {\n        this.catcher = this._uncaughtException.bind(this);\n        process.on('uncaughtException', this.catcher);\n      }\n    }\n\n    /**\n     * Removes any handlers to `uncaughtException` events for the current\n     * process. This does not modify the state of the `this.handlers` set.\n     * @returns {undefined}\n     */\n  }, {\n    key: \"unhandle\",\n    value: function unhandle() {\n      var _this2 = this;\n      if (this.catcher) {\n        process.removeListener('uncaughtException', this.catcher);\n        this.catcher = false;\n        Array.from(this.handlers.values()).forEach(function (wrapper) {\n          return _this2.logger.unpipe(wrapper);\n        });\n      }\n    }\n\n    /**\n     * TODO: add method description\n     * @param {Error} err - Error to get information about.\n     * @returns {mixed} - TODO: add return description.\n     */\n  }, {\n    key: \"getAllInfo\",\n    value: function getAllInfo(err) {\n      var message = null;\n      if (err) {\n        message = typeof err === 'string' ? err : err.message;\n      }\n      return {\n        error: err,\n        // TODO (indexzero): how do we configure this?\n        level: 'error',\n        message: [\"uncaughtException: \".concat(message || '(no error message)'), err && err.stack || '  No stack trace'].join('\\n'),\n        stack: err && err.stack,\n        exception: true,\n        date: new Date().toString(),\n        process: this.getProcessInfo(),\n        os: this.getOsInfo(),\n        trace: this.getTrace(err)\n      };\n    }\n\n    /**\n     * Gets all relevant process information for the currently running process.\n     * @returns {mixed} - TODO: add return description.\n     */\n  }, {\n    key: \"getProcessInfo\",\n    value: function getProcessInfo() {\n      return {\n        pid: process.pid,\n        uid: process.getuid ? process.getuid() : null,\n        gid: process.getgid ? process.getgid() : null,\n        cwd: process.cwd(),\n        execPath: process.execPath,\n        version: process.version,\n        argv: process.argv,\n        memoryUsage: process.memoryUsage()\n      };\n    }\n\n    /**\n     * Gets all relevant OS information for the currently running process.\n     * @returns {mixed} - TODO: add return description.\n     */\n  }, {\n    key: \"getOsInfo\",\n    value: function getOsInfo() {\n      return {\n        loadavg: os.loadavg(),\n        uptime: os.uptime()\n      };\n    }\n\n    /**\n     * Gets a stack trace for the specified error.\n     * @param {mixed} err - TODO: add param description.\n     * @returns {mixed} - TODO: add return description.\n     */\n  }, {\n    key: \"getTrace\",\n    value: function getTrace(err) {\n      var trace = err ? stackTrace.parse(err) : stackTrace.get();\n      return trace.map(function (site) {\n        return {\n          column: site.getColumnNumber(),\n          file: site.getFileName(),\n          \"function\": site.getFunctionName(),\n          line: site.getLineNumber(),\n          method: site.getMethodName(),\n          \"native\": site.isNative()\n        };\n      });\n    }\n\n    /**\n     * Helper method to add a transport as an exception handler.\n     * @param {Transport} handler - The transport to add as an exception handler.\n     * @returns {void}\n     */\n  }, {\n    key: \"_addHandler\",\n    value: function _addHandler(handler) {\n      if (!this.handlers.has(handler)) {\n        handler.handleExceptions = true;\n        var wrapper = new ExceptionStream(handler);\n        this.handlers.set(handler, wrapper);\n        this.logger.pipe(wrapper);\n      }\n    }\n\n    /**\n     * Logs all relevant information around the `err` and exits the current\n     * process.\n     * @param {Error} err - Error to handle\n     * @returns {mixed} - TODO: add return description.\n     * @private\n     */\n  }, {\n    key: \"_uncaughtException\",\n    value: function _uncaughtException(err) {\n      var info = this.getAllInfo(err);\n      var handlers = this._getExceptionHandlers();\n      // Calculate if we should exit on this error\n      var doExit = typeof this.logger.exitOnError === 'function' ? this.logger.exitOnError(err) : this.logger.exitOnError;\n      var timeout;\n      if (!handlers.length && doExit) {\n        // eslint-disable-next-line no-console\n        console.warn('winston: exitOnError cannot be true with no exception handlers.');\n        // eslint-disable-next-line no-console\n        console.warn('winston: not exiting process.');\n        doExit = false;\n      }\n      function gracefulExit() {\n        debug('doExit', doExit);\n        debug('process._exiting', process._exiting);\n        if (doExit && !process._exiting) {\n          // Remark: Currently ignoring any exceptions from transports when\n          // catching uncaught exceptions.\n          if (timeout) {\n            clearTimeout(timeout);\n          }\n          // eslint-disable-next-line no-process-exit\n          process.exit(1);\n        }\n      }\n      if (!handlers || handlers.length === 0) {\n        return process.nextTick(gracefulExit);\n      }\n\n      // Log to all transports attempting to listen for when they are completed.\n      asyncForEach(handlers, function (handler, next) {\n        var done = once(next);\n        var transport = handler.transport || handler;\n\n        // Debug wrapping so that we can inspect what's going on under the covers.\n        function onDone(event) {\n          return function () {\n            debug(event);\n            done();\n          };\n        }\n        transport._ending = true;\n        transport.once('finish', onDone('finished'));\n        transport.once('error', onDone('error'));\n      }, function () {\n        return doExit && gracefulExit();\n      });\n      this.logger.log(info);\n\n      // If exitOnError is true, then only allow the logging of exceptions to\n      // take up to `3000ms`.\n      if (doExit) {\n        timeout = setTimeout(gracefulExit, 3000);\n      }\n    }\n\n    /**\n     * Returns the list of transports and exceptionHandlers for this instance.\n     * @returns {Array} - List of transports and exceptionHandlers for this\n     * instance.\n     * @private\n     */\n  }, {\n    key: \"_getExceptionHandlers\",\n    value: function _getExceptionHandlers() {\n      // Remark (indexzero): since `logger.transports` returns all of the pipes\n      // from the _readableState of the stream we actually get the join of the\n      // explicit handlers and the implicit transports with\n      // `handleExceptions: true`\n      return this.logger.transports.filter(function (wrap) {\n        var transport = wrap.transport || wrap;\n        return transport.handleExceptions;\n      });\n    }\n  }]);\n}();","map":null,"metadata":{},"sourceType":"script"}