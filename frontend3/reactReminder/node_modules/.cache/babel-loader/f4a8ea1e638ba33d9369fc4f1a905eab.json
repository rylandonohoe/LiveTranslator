{"ast":null,"code":"import { Directives } from '../doc/directives.js';\nimport { Document } from '../doc/Document.js';\nimport { YAMLWarning, YAMLParseError } from '../errors.js';\nimport { isCollection, isPair } from '../nodes/identity.js';\nimport { composeDoc } from './compose-doc.js';\nimport { resolveEnd } from './resolve-end.js';\nfunction getErrorPos(src) {\n  if (typeof src === 'number') return [src, src + 1];\n  if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];\n  const offset = src.offset,\n    source = src.source;\n  return [offset, offset + (typeof source === 'string' ? source.length : 1)];\n}\nfunction parsePrelude(prelude) {\n  let comment = '';\n  let atComment = false;\n  let afterEmptyLine = false;\n  for (let i = 0; i < prelude.length; ++i) {\n    const source = prelude[i];\n    switch (source[0]) {\n      case '#':\n        comment += (comment === '' ? '' : afterEmptyLine ? '\\n\\n' : '\\n') + (source.substring(1) || ' ');\n        atComment = true;\n        afterEmptyLine = false;\n        break;\n      case '%':\n        if (prelude[i + 1]?.[0] !== '#') i += 1;\n        atComment = false;\n        break;\n      default:\n        // This may be wrong after doc-end, but in that case it doesn't matter\n        if (!atComment) afterEmptyLine = true;\n        atComment = false;\n    }\n  }\n  return {\n    comment,\n    afterEmptyLine\n  };\n}\n/**\n * Compose a stream of CST nodes into a stream of YAML Documents.\n *\n * ```ts\n * import { Composer, Parser } from 'yaml'\n *\n * const src: string = ...\n * const tokens = new Parser().parse(src)\n * const docs = new Composer().compose(tokens)\n * ```\n */\nclass Composer {\n  constructor(options = {}) {\n    this.doc = null;\n    this.atDirectives = false;\n    this.prelude = [];\n    this.errors = [];\n    this.warnings = [];\n    this.onError = (source, code, message, warning) => {\n      const pos = getErrorPos(source);\n      if (warning) this.warnings.push(new YAMLWarning(pos, code, message));else this.errors.push(new YAMLParseError(pos, code, message));\n    };\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    this.directives = new Directives({\n      version: options.version || '1.2'\n    });\n    this.options = options;\n  }\n  decorate(doc, afterDoc) {\n    const _parsePrelude = parsePrelude(this.prelude),\n      comment = _parsePrelude.comment,\n      afterEmptyLine = _parsePrelude.afterEmptyLine; //console.log({ dc: doc.comment, prelude, comment })\n    if (comment) {\n      const dc = doc.contents;\n      if (afterDoc) {\n        doc.comment = doc.comment ? \"\".concat(doc.comment, \"\\n\").concat(comment) : comment;\n      } else if (afterEmptyLine || doc.directives.docStart || !dc) {\n        doc.commentBefore = comment;\n      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {\n        let it = dc.items[0];\n        if (isPair(it)) it = it.key;\n        const cb = it.commentBefore;\n        it.commentBefore = cb ? \"\".concat(comment, \"\\n\").concat(cb) : comment;\n      } else {\n        const cb = dc.commentBefore;\n        dc.commentBefore = cb ? \"\".concat(comment, \"\\n\").concat(cb) : comment;\n      }\n    }\n    if (afterDoc) {\n      Array.prototype.push.apply(doc.errors, this.errors);\n      Array.prototype.push.apply(doc.warnings, this.warnings);\n    } else {\n      doc.errors = this.errors;\n      doc.warnings = this.warnings;\n    }\n    this.prelude = [];\n    this.errors = [];\n    this.warnings = [];\n  }\n  /**\n   * Current stream status information.\n   *\n   * Mostly useful at the end of input for an empty stream.\n   */\n  streamInfo() {\n    return {\n      comment: parsePrelude(this.prelude).comment,\n      directives: this.directives,\n      errors: this.errors,\n      warnings: this.warnings\n    };\n  }\n  /**\n   * Compose tokens into documents.\n   *\n   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n   */\n  *compose(tokens, forceDoc = false, endOffset = -1) {\n    for (const token of tokens) yield* this.next(token);\n    yield* this.end(forceDoc, endOffset);\n  }\n  /** Advance the composer by one CST token. */\n  *next(token) {\n    switch (token.type) {\n      case 'directive':\n        this.directives.add(token.source, (offset, message, warning) => {\n          const pos = getErrorPos(token);\n          pos[0] += offset;\n          this.onError(pos, 'BAD_DIRECTIVE', message, warning);\n        });\n        this.prelude.push(token.source);\n        this.atDirectives = true;\n        break;\n      case 'document':\n        {\n          const doc = composeDoc(this.options, this.directives, token, this.onError);\n          if (this.atDirectives && !doc.directives.docStart) this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');\n          this.decorate(doc, false);\n          if (this.doc) yield this.doc;\n          this.doc = doc;\n          this.atDirectives = false;\n          break;\n        }\n      case 'byte-order-mark':\n      case 'space':\n        break;\n      case 'comment':\n      case 'newline':\n        this.prelude.push(token.source);\n        break;\n      case 'error':\n        {\n          const msg = token.source ? \"\".concat(token.message, \": \").concat(JSON.stringify(token.source)) : token.message;\n          const error = new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);\n          if (this.atDirectives || !this.doc) this.errors.push(error);else this.doc.errors.push(error);\n          break;\n        }\n      case 'doc-end':\n        {\n          if (!this.doc) {\n            const msg = 'Unexpected doc-end without preceding document';\n            this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));\n            break;\n          }\n          this.doc.directives.docEnd = true;\n          const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);\n          this.decorate(this.doc, true);\n          if (end.comment) {\n            const dc = this.doc.comment;\n            this.doc.comment = dc ? \"\".concat(dc, \"\\n\").concat(end.comment) : end.comment;\n          }\n          this.doc.range[2] = end.offset;\n          break;\n        }\n      default:\n        this.errors.push(new YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', \"Unsupported token \".concat(token.type)));\n    }\n  }\n  /**\n   * Call at end of input to yield any remaining document.\n   *\n   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.\n   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.\n   */\n  *end(forceDoc = false, endOffset = -1) {\n    if (this.doc) {\n      this.decorate(this.doc, true);\n      yield this.doc;\n      this.doc = null;\n    } else if (forceDoc) {\n      const opts = Object.assign({\n        _directives: this.directives\n      }, this.options);\n      const doc = new Document(undefined, opts);\n      if (this.atDirectives) this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');\n      doc.range = [0, endOffset, endOffset];\n      this.decorate(doc, false);\n      yield doc;\n    }\n  }\n}\nexport { Composer };","map":null,"metadata":{},"sourceType":"module"}