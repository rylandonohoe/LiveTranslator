{"ast":null,"code":"export { createScalarToken, resolveAsScalar, setScalarValue } from './cst-scalar.js';\nexport { stringify } from './cst-stringify.js';\nexport { visit } from './cst-visit.js';\n\n/** The byte order mark */\nconst BOM = '\\u{FEFF}';\n/** Start of doc-mode */\nconst DOCUMENT = '\\x02'; // C0: Start of Text\n/** Unexpected end of flow-mode */\nconst FLOW_END = '\\x18'; // C0: Cancel\n/** Next token is a scalar value */\nconst SCALAR = '\\x1f'; // C0: Unit Separator\n/** @returns `true` if `token` is a flow or block collection */\nconst isCollection = token => !!token && 'items' in token;\n/** @returns `true` if `token` is a flow or block scalar; not an alias */\nconst isScalar = token => !!token && (token.type === 'scalar' || token.type === 'single-quoted-scalar' || token.type === 'double-quoted-scalar' || token.type === 'block-scalar');\n/* istanbul ignore next */\n/** Get a printable representation of a lexer token */\nfunction prettyToken(token) {\n  switch (token) {\n    case BOM:\n      return '<BOM>';\n    case DOCUMENT:\n      return '<DOC>';\n    case FLOW_END:\n      return '<FLOW_END>';\n    case SCALAR:\n      return '<SCALAR>';\n    default:\n      return JSON.stringify(token);\n  }\n}\n/** Identify the type of a lexer token. May return `null` for unknown tokens. */\nfunction tokenType(source) {\n  switch (source) {\n    case BOM:\n      return 'byte-order-mark';\n    case DOCUMENT:\n      return 'doc-mode';\n    case FLOW_END:\n      return 'flow-error-end';\n    case SCALAR:\n      return 'scalar';\n    case '---':\n      return 'doc-start';\n    case '...':\n      return 'doc-end';\n    case '':\n    case '\\n':\n    case '\\r\\n':\n      return 'newline';\n    case '-':\n      return 'seq-item-ind';\n    case '?':\n      return 'explicit-key-ind';\n    case ':':\n      return 'map-value-ind';\n    case '{':\n      return 'flow-map-start';\n    case '}':\n      return 'flow-map-end';\n    case '[':\n      return 'flow-seq-start';\n    case ']':\n      return 'flow-seq-end';\n    case ',':\n      return 'comma';\n  }\n  switch (source[0]) {\n    case ' ':\n    case '\\t':\n      return 'space';\n    case '#':\n      return 'comment';\n    case '%':\n      return 'directive-line';\n    case '*':\n      return 'alias';\n    case '&':\n      return 'anchor';\n    case '!':\n      return 'tag';\n    case \"'\":\n      return 'single-quoted-scalar';\n    case '\"':\n      return 'double-quoted-scalar';\n    case '|':\n    case '>':\n      return 'block-scalar-header';\n  }\n  return null;\n}\nexport { BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, prettyToken, tokenType };","map":null,"metadata":{},"sourceType":"module"}