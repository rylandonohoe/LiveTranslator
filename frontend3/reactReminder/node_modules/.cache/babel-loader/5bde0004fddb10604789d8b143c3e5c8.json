{"ast":null,"code":"// @flow\n\n/**\n * `autocomplete` type prompt\n */\n\n'use strict';\n\nconst ansiEscapes = require('ansi-escapes');\nconst figures = require('figures');\nconst Base = require('inquirer/lib/prompts/base');\nconst Choices = require('inquirer/lib/objects/choices');\nconst observe = require('inquirer/lib/utils/events');\nconst utils = require('inquirer/lib/utils/readline');\nconst Paginator = require('inquirer/lib/utils/paginator');\nconst pc = require('picocolors');\nconst runAsync = require('run-async');\nconst _require = require('rxjs/operators'),\n  takeWhile = _require.takeWhile;\nconst isSelectable = choice => choice.type !== 'separator' && !choice.disabled;\nclass AutocompletePrompt extends Base {\n  constructor(questions /*: Array<any> */, rl /*: readline$Interface */, answers /*: Array<any> */) {\n    super(questions, rl, answers);\n    if (!this.opt.source) {\n      this.throwParamError('source');\n    }\n    this.currentChoices = new Choices([]);\n    this.firstRender = true;\n    this.selected = 0;\n\n    // Make sure no default is set (so it won't be printed)\n    this.initialValue = this.opt.default;\n    if (!this.opt.suggestOnly) {\n      this.opt.default = null;\n    }\n    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;\n    this.paginator = new Paginator(this.screen, {\n      isInfinite: shouldLoop\n    });\n  }\n\n  /**\n   * Start the Inquiry session\n   * @param  {Function} cb      Callback when prompt is done\n   * @return {this}\n   */\n  _run(cb /*: Function */) /*: this*/{\n    this.done = cb;\n    if (Array.isArray(this.rl.history)) {\n      this.rl.history = [];\n    }\n    const events = observe(this.rl);\n    const dontHaveAnswer = () => this.answer === undefined;\n    events.line.pipe(takeWhile(dontHaveAnswer)) // $FlowFixMe[method-unbinding]\n    .forEach(this.onSubmit.bind(this));\n    events.keypress.pipe(takeWhile(dontHaveAnswer)) // $FlowFixMe[method-unbinding]\n    .forEach(this.onKeypress.bind(this));\n\n    // Call once at init\n    this.search(undefined);\n    return this;\n  }\n\n  /**\n   * Render the prompt to screen\n   * @return {undefined}\n   */\n  render(error /*: ?string */) {\n    // Render question\n    let content = this.getQuestion();\n    let bottomContent = '';\n    if (this.firstRender) {\n      const suggestText = this.opt.suggestOnly ? ', tab to autocomplete' : '';\n      content += pc.dim('(Use arrow keys or type to search' + suggestText + ')');\n    }\n\n    // Render choices or answer depending on the state\n    if (this.status === 'answered') {\n      content += pc.cyan(this.shortAnswer || this.answerName || this.answer);\n    } else if (this.searching) {\n      content += this.rl.line;\n      bottomContent += '  ' + pc.dim(this.opt.searchText || 'Searching...');\n    } else if (this.nbChoices) {\n      const choicesStr = listRender(this.currentChoices, this.selected);\n      content += this.rl.line;\n      const indexPosition = this.selected;\n      let realIndexPosition = 0;\n      this.currentChoices.choices.every((choice, index) => {\n        if (index > indexPosition) {\n          return false;\n        }\n        const name = choice.name;\n        realIndexPosition += name ? name.split('\\n').length : 0;\n        return true;\n      });\n      bottomContent += this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);\n    } else {\n      content += this.rl.line;\n      bottomContent += '  ' + pc.yellow(this.opt.emptyText || 'No results...');\n    }\n    if (error) {\n      bottomContent += '\\n' + pc.red('>> ') + error;\n    }\n    this.firstRender = false;\n    this.screen.render(content, bottomContent);\n  }\n\n  /**\n   * When user press `enter` key\n   */\n  onSubmit(line /* : string */) {\n    let lineOrRl = line || this.rl.line;\n\n    // only set default when suggestOnly (behaving as input prompt)\n    // list prompt does only set default if matching actual item in list\n    if (this.opt.suggestOnly && !lineOrRl) {\n      lineOrRl = this.opt.default === null ? '' : this.opt.default;\n    }\n    if (typeof this.opt.validate === 'function') {\n      const checkValidationResult = validationResult => {\n        if (validationResult !== true) {\n          this.render(validationResult || 'Enter something, tab to autocomplete!');\n        } else {\n          this.onSubmitAfterValidation(lineOrRl);\n        }\n      };\n      let validationResult;\n      if (this.opt.suggestOnly) {\n        validationResult = this.opt.validate(lineOrRl, this.answers);\n      } else {\n        const choice = this.currentChoices.getChoice(this.selected);\n        validationResult = this.opt.validate(choice, this.answers);\n      }\n      if (isPromise(validationResult)) {\n        validationResult.then(checkValidationResult);\n      } else {\n        checkValidationResult(validationResult);\n      }\n    } else {\n      this.onSubmitAfterValidation(lineOrRl);\n    }\n  }\n  onSubmitAfterValidation(line /* : string */) {\n    let choice = {};\n    if (this.nbChoices <= this.selected && !this.opt.suggestOnly) {\n      this.rl.write(line);\n      this.search(line);\n      return;\n    }\n    if (this.opt.suggestOnly) {\n      choice.value = line || this.rl.line;\n      this.answer = line || this.rl.line;\n      this.answerName = line || this.rl.line;\n      this.shortAnswer = line || this.rl.line;\n      this.rl.line = '';\n    } else if (this.nbChoices) {\n      choice = this.currentChoices.getChoice(this.selected);\n      this.answer = choice.value;\n      this.answerName = choice.name;\n      this.shortAnswer = choice.short;\n    } else {\n      this.rl.write(line);\n      this.search(line);\n      return;\n    }\n    runAsync(this.opt.filter, (err, value) => {\n      choice.value = value;\n      this.answer = value;\n      if (this.opt.suggestOnly) {\n        this.shortAnswer = value;\n      }\n      this.status = 'answered';\n      // Rerender prompt\n      this.render();\n      this.screen.done();\n      this.done(choice.value);\n    })(choice.value);\n  }\n  search(searchTerm /* : ?string */) /*: Promise<any>*/{\n    this.selected = 0;\n\n    // Only render searching state after first time\n    if (this.searchedOnce) {\n      this.searching = true;\n      this.currentChoices = new Choices([]);\n      this.render(); // Now render current searching state\n    } else {\n      this.searchedOnce = true;\n    }\n    this.lastSearchTerm = searchTerm;\n    let thisPromise;\n    try {\n      const result = this.opt.source(this.answers, searchTerm);\n      thisPromise = Promise.resolve(result);\n    } catch (error) {\n      thisPromise = Promise.reject(error);\n    }\n\n    // Store this promise for check in the callback\n    this.lastPromise = thisPromise;\n    return thisPromise.then(choices => {\n      // If another search is triggered before the current search finishes, don't set results\n      if (thisPromise !== this.lastPromise) return;\n      this.currentChoices = new Choices(choices);\n      const realChoices = choices.filter(choice => isSelectable(choice));\n      this.nbChoices = realChoices.length;\n      const selectedIndex = realChoices.findIndex(choice => choice === this.initialValue || choice.value === this.initialValue);\n      if (selectedIndex >= 0) {\n        this.selected = selectedIndex;\n      }\n      this.searching = false;\n      this.render();\n    });\n  }\n  ensureSelectedInRange() {\n    const selectedIndex = Math.min(this.selected, this.nbChoices); // Not above currentChoices length - 1\n    this.selected = Math.max(selectedIndex, 0); // Not below 0\n  }\n\n  /**\n   * When user type\n   */\n\n  onKeypress(e /* : {key: { name: string, ctrl: boolean }, value: string } */) {\n    let len;\n    const keyName = e.key && e.key.name || undefined;\n    if (keyName === 'tab' && this.opt.suggestOnly) {\n      if (this.currentChoices.getChoice(this.selected)) {\n        this.rl.write(ansiEscapes.cursorLeft);\n        const autoCompleted = this.currentChoices.getChoice(this.selected).value;\n        this.rl.write(ansiEscapes.cursorForward(autoCompleted.length));\n        this.rl.line = autoCompleted;\n        this.render();\n      }\n    } else if (keyName === 'down' || keyName === 'n' && e.key.ctrl) {\n      len = this.nbChoices;\n      this.selected = this.selected < len - 1 ? this.selected + 1 : 0;\n      this.ensureSelectedInRange();\n      this.render();\n      utils.up(this.rl, 2);\n    } else if (keyName === 'up' || keyName === 'p' && e.key.ctrl) {\n      len = this.nbChoices;\n      this.selected = this.selected > 0 ? this.selected - 1 : len - 1;\n      this.ensureSelectedInRange();\n      this.render();\n    } else {\n      this.render(); // Render input automatically\n      // Only search if input have actually changed, not because of other keypresses\n      if (this.lastSearchTerm !== this.rl.line) {\n        this.search(this.rl.line); // Trigger new search\n      }\n    }\n  }\n}\n\n/**\n * Function for rendering list choices\n * @param  {Number} pointer Position of the pointer\n * @return {String}         Rendered content\n */\nfunction listRender(choices, pointer /*: string */) /*: string */{\n  let output = '';\n  let separatorOffset = 0;\n  choices.forEach((choice, i) => {\n    if (choice.type === 'separator') {\n      separatorOffset++;\n      output += '  ' + choice + '\\n';\n      return;\n    }\n    if (choice.disabled) {\n      separatorOffset++;\n      output += '  - ' + choice.name;\n      output += ' (' + (typeof choice.disabled === 'string' ? choice.disabled : 'Disabled') + ')';\n      output += '\\n';\n      return;\n    }\n    const isSelected = i - separatorOffset === pointer;\n    let line = (isSelected ? figures.pointer + ' ' : '  ') + choice.name;\n    if (isSelected) {\n      line = pc.cyan(line);\n    }\n    output += line + ' \\n';\n  });\n  return output.replace(/\\n$/, '');\n}\nfunction isPromise(value) {\n  return typeof value === 'object' && typeof value.then === 'function';\n}\nmodule.exports = AutocompletePrompt;","map":null,"metadata":{},"sourceType":"script"}