{"ast":null,"code":"import { Composer } from './compose/composer.js';\nimport { Document } from './doc/Document.js';\nimport { prettifyError, YAMLParseError } from './errors.js';\nimport { warn } from './log.js';\nimport { isDocument } from './nodes/identity.js';\nimport { LineCounter } from './parse/line-counter.js';\nimport { Parser } from './parse/parser.js';\nfunction parseOptions(options) {\n  const prettyErrors = options.prettyErrors !== false;\n  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;\n  return {\n    lineCounter,\n    prettyErrors\n  };\n}\n/**\n * Parse the input as a stream of YAML documents.\n *\n * Documents should be separated from each other by `...` or `---` marker lines.\n *\n * @returns If an empty `docs` array is returned, it will be of type\n *   EmptyStream and contain additional stream information. In\n *   TypeScript, you should use `'empty' in docs` as a type guard for it.\n */\nfunction parseAllDocuments(source, options = {}) {\n  const _parseOptions = parseOptions(options),\n    lineCounter = _parseOptions.lineCounter,\n    prettyErrors = _parseOptions.prettyErrors;\n  const parser = new Parser(lineCounter?.addNewLine);\n  const composer = new Composer(options);\n  const docs = Array.from(composer.compose(parser.parse(source)));\n  if (prettyErrors && lineCounter) for (const doc of docs) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  if (docs.length > 0) return docs;\n  return Object.assign([], {\n    empty: true\n  }, composer.streamInfo());\n}\n/** Parse an input string into a single YAML.Document */\nfunction parseDocument(source, options = {}) {\n  const _parseOptions2 = parseOptions(options),\n    lineCounter = _parseOptions2.lineCounter,\n    prettyErrors = _parseOptions2.prettyErrors;\n  const parser = new Parser(lineCounter?.addNewLine);\n  const composer = new Composer(options);\n  // `doc` is always set by compose.end(true) at the very latest\n  let doc = null;\n  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {\n    if (!doc) doc = _doc;else if (doc.options.logLevel !== 'silent') {\n      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));\n      break;\n    }\n  }\n  if (prettyErrors && lineCounter) {\n    doc.errors.forEach(prettifyError(source, lineCounter));\n    doc.warnings.forEach(prettifyError(source, lineCounter));\n  }\n  return doc;\n}\nfunction parse(src, reviver, options) {\n  let _reviver = undefined;\n  if (typeof reviver === 'function') {\n    _reviver = reviver;\n  } else if (options === undefined && reviver && typeof reviver === 'object') {\n    options = reviver;\n  }\n  const doc = parseDocument(src, options);\n  if (!doc) return null;\n  doc.warnings.forEach(warning => warn(doc.options.logLevel, warning));\n  if (doc.errors.length > 0) {\n    if (doc.options.logLevel !== 'silent') throw doc.errors[0];else doc.errors = [];\n  }\n  return doc.toJS(Object.assign({\n    reviver: _reviver\n  }, options));\n}\nfunction stringify(value, replacer, options) {\n  let _replacer = null;\n  if (typeof replacer === 'function' || Array.isArray(replacer)) {\n    _replacer = replacer;\n  } else if (options === undefined && replacer) {\n    options = replacer;\n  }\n  if (typeof options === 'string') options = options.length;\n  if (typeof options === 'number') {\n    const indent = Math.round(options);\n    options = indent < 1 ? undefined : indent > 8 ? {\n      indent: 8\n    } : {\n      indent\n    };\n  }\n  if (value === undefined) {\n    const _ref = options ?? replacer ?? {},\n      keepUndefined = _ref.keepUndefined;\n    if (!keepUndefined) return undefined;\n  }\n  if (isDocument(value) && !_replacer) return value.toString(options);\n  return new Document(value, _replacer, options).toString(options);\n}\nexport { parse, parseAllDocuments, parseDocument, stringify };","map":null,"metadata":{},"sourceType":"module"}