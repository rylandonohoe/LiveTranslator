{"ast":null,"code":"'use strict';\n\n/**\n * `list` type prompt\n */\nconst chalk = require('chalk');\nconst cliCursor = require('cli-cursor');\nconst figures = require('figures');\nconst _require = require('rxjs/operators'),\n  map = _require.map,\n  takeUntil = _require.takeUntil;\nconst Base = require('./base');\nconst observe = require('../utils/events');\nconst Paginator = require('../utils/paginator');\nconst incrementListIndex = require('../utils/incrementListIndex');\nclass CheckboxPrompt extends Base {\n  constructor(questions, rl, answers) {\n    super(questions, rl, answers);\n    if (!this.opt.choices) {\n      this.throwParamError('choices');\n    }\n    if (Array.isArray(this.opt.default)) {\n      this.opt.choices.forEach(function (choice) {\n        if (this.opt.default.indexOf(choice.value) >= 0) {\n          choice.checked = true;\n        }\n      }, this);\n    }\n    this.pointer = 0;\n\n    // Make sure no default is set (so it won't be printed)\n    this.opt.default = null;\n    const shouldLoop = this.opt.loop === undefined ? true : this.opt.loop;\n    this.paginator = new Paginator(this.screen, {\n      isInfinite: shouldLoop\n    });\n  }\n\n  /**\n   * Start the Inquiry session\n   * @param  {Function} cb      Callback when prompt is done\n   * @return {this}\n   */\n\n  _run(cb) {\n    this.done = cb;\n    const events = observe(this.rl);\n    const validation = this.handleSubmitEvents(events.line.pipe(map(this.getCurrentValue.bind(this))));\n    validation.success.forEach(this.onEnd.bind(this));\n    validation.error.forEach(this.onError.bind(this));\n    events.normalizedUpKey.pipe(takeUntil(validation.success)).forEach(this.onUpKey.bind(this));\n    events.normalizedDownKey.pipe(takeUntil(validation.success)).forEach(this.onDownKey.bind(this));\n    events.numberKey.pipe(takeUntil(validation.success)).forEach(this.onNumberKey.bind(this));\n    events.spaceKey.pipe(takeUntil(validation.success)).forEach(this.onSpaceKey.bind(this));\n    events.aKey.pipe(takeUntil(validation.success)).forEach(this.onAllKey.bind(this));\n    events.iKey.pipe(takeUntil(validation.success)).forEach(this.onInverseKey.bind(this));\n\n    // Init the prompt\n    cliCursor.hide();\n    this.render();\n    this.firstRender = false;\n    return this;\n  }\n\n  /**\n   * Render the prompt to screen\n   * @return {CheckboxPrompt} self\n   */\n\n  render(error) {\n    // Render question\n    let message = this.getQuestion();\n    let bottomContent = '';\n    if (!this.dontShowHints) {\n      message += '(Press ' + chalk.cyan.bold('<space>') + ' to select, ' + chalk.cyan.bold('<a>') + ' to toggle all, ' + chalk.cyan.bold('<i>') + ' to invert selection, and ' + chalk.cyan.bold('<enter>') + ' to proceed)';\n    }\n\n    // Render choices or answer depending on the state\n    if (this.status === 'answered') {\n      message += chalk.cyan(this.selection.join(', '));\n    } else {\n      const choicesStr = renderChoices(this.opt.choices, this.pointer);\n      const indexPosition = this.opt.choices.indexOf(this.opt.choices.getChoice(this.pointer));\n      const realIndexPosition = this.opt.choices.reduce((acc, value, i) => {\n        // Dont count lines past the choice we are looking at\n        if (i > indexPosition) {\n          return acc;\n        }\n        // Add line if it's a separator\n        if (value.type === 'separator') {\n          return acc + 1;\n        }\n        let l = value.name;\n        // Non-strings take up one line\n        if (typeof l !== 'string') {\n          return acc + 1;\n        }\n\n        // Calculate lines taken up by string\n        l = l.split('\\n');\n        return acc + l.length;\n      }, 0) - 1;\n      message += '\\n' + this.paginator.paginate(choicesStr, realIndexPosition, this.opt.pageSize);\n    }\n    if (error) {\n      bottomContent = chalk.red('>> ') + error;\n    }\n    this.screen.render(message, bottomContent);\n  }\n\n  /**\n   * When user press `enter` key\n   */\n\n  onEnd(state) {\n    this.status = 'answered';\n    this.dontShowHints = true;\n    // Rerender prompt (and clean subline error)\n    this.render();\n    this.screen.done();\n    cliCursor.show();\n    this.done(state.value);\n  }\n  onError(state) {\n    this.render(state.isValid);\n  }\n  getCurrentValue() {\n    const choices = this.opt.choices.filter(choice => Boolean(choice.checked) && !choice.disabled);\n    this.selection = choices.map(choice => choice.short);\n    return choices.map(choice => choice.value);\n  }\n  onUpKey() {\n    this.pointer = incrementListIndex(this.pointer, 'up', this.opt);\n    this.render();\n  }\n  onDownKey() {\n    this.pointer = incrementListIndex(this.pointer, 'down', this.opt);\n    this.render();\n  }\n  onNumberKey(input) {\n    if (input <= this.opt.choices.realLength) {\n      this.pointer = input - 1;\n      this.toggleChoice(this.pointer);\n    }\n    this.render();\n  }\n  onSpaceKey() {\n    this.toggleChoice(this.pointer);\n    this.render();\n  }\n  onAllKey() {\n    const shouldBeChecked = Boolean(this.opt.choices.find(choice => choice.type !== 'separator' && !choice.checked));\n    this.opt.choices.forEach(choice => {\n      if (choice.type !== 'separator') {\n        choice.checked = shouldBeChecked;\n      }\n    });\n    this.render();\n  }\n  onInverseKey() {\n    this.opt.choices.forEach(choice => {\n      if (choice.type !== 'separator') {\n        choice.checked = !choice.checked;\n      }\n    });\n    this.render();\n  }\n  toggleChoice(index) {\n    const item = this.opt.choices.getChoice(index);\n    if (item !== undefined) {\n      this.opt.choices.getChoice(index).checked = !item.checked;\n    }\n  }\n}\n\n/**\n * Function for rendering checkbox choices\n * @param  {Number} pointer Position of the pointer\n * @return {String}         Rendered content\n */\n\nfunction renderChoices(choices, pointer) {\n  let output = '';\n  let separatorOffset = 0;\n  choices.forEach((choice, i) => {\n    if (choice.type === 'separator') {\n      separatorOffset++;\n      output += ' ' + choice + '\\n';\n      return;\n    }\n    if (choice.disabled) {\n      separatorOffset++;\n      output += ' - ' + choice.name;\n      output += \" (\".concat(typeof choice.disabled === 'string' ? choice.disabled : 'Disabled', \")\");\n    } else {\n      const line = getCheckbox(choice.checked) + ' ' + choice.name;\n      if (i - separatorOffset === pointer) {\n        output += chalk.cyan(figures.pointer + line);\n      } else {\n        output += ' ' + line;\n      }\n    }\n    output += '\\n';\n  });\n  return output.replace(/\\n$/, '');\n}\n\n/**\n * Get the checkbox\n * @param  {Boolean} checked - add a X or not to the checkbox\n * @return {String} Composited checkbox string\n */\n\nfunction getCheckbox(checked) {\n  return checked ? chalk.green(figures.radioOn) : figures.radioOff;\n}\nmodule.exports = CheckboxPrompt;","map":null,"metadata":{},"sourceType":"script"}