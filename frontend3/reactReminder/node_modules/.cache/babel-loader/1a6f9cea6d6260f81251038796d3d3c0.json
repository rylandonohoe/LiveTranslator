{"ast":null,"code":"export const createOffer = async (connection, localStream, userToCall, doOffer, database, username) => {\n  try {\n    connection.addStream(localStream);\n    const offer = await connection.createOffer();\n    await connection.setLocalDescription(offer);\n    doOffer(userToCall, offer, database, username);\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const initiateLocalStream = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    });\n    return stream;\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const initiateConnection = async () => {\n  try {\n    // using Google public stun server\n    var configuration = {\n      iceServers: [{\n        urls: 'stun:stun2.1.google.com:19302'\n      }]\n    };\n    const conn = new RTCPeerConnection(configuration);\n    return conn;\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const sendAudioStream = async (audioStream, websocket) => {\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const recorder = new MediaRecorder(audioStream, {\n    mimeType: 'audio/webm'\n  });\n  recorder.ondataavailable = async event => {\n    // Convert the audio blob to Base64\n    const audioBlob = event.data;\n    const reader = new FileReader();\n    reader.readAsDataURL(audioBlob);\n    reader.onloadend = () => {\n      const base64data = reader.result.split(',')[1]; // Strip the Base64 metadata prefix\n      websocket.send(base64data);\n    };\n  };\n  recorder.start(1000); // Send audio in 1-second chunks\n};\nexport const listenToConnectionEvents = (conn, username, remoteUsername, database, remoteVideoRef, doCandidate) => {\n  conn.onicecandidate = function (event) {\n    if (event.candidate) {\n      doCandidate(remoteUsername, event.candidate, database, username);\n    }\n  };\n\n  // when a remote user adds stream to the peer connection, we display it\n  conn.ontrack = function (e) {\n    if (remoteVideoRef.srcObject !== e.streams[0]) {\n      remoteVideoRef.srcObject = e.streams[0];\n    }\n  };\n};\nexport const sendAnswer = async (conn, localStream, notif, doAnswer, database, username) => {\n  try {\n    conn.addStream(localStream);\n    const offer = JSON.parse(notif.offer);\n    conn.setRemoteDescription(offer);\n\n    // create an answer to an offer\n    const answer = await conn.createAnswer();\n    conn.setLocalDescription(answer);\n    doAnswer(notif.from, answer, database, username);\n  } catch (exception) {\n    console.error(exception);\n  }\n};\nexport const startCall = (yourConn, notif) => {\n  const answer = JSON.parse(notif.answer);\n  yourConn.setRemoteDescription(answer);\n};\nexport const addCandidate = (yourConn, notif) => {\n  // apply the new received candidate to the connection\n  const candidate = JSON.parse(notif.candidate);\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate));\n};","map":{"version":3,"names":["createOffer","connection","localStream","userToCall","doOffer","database","username","addStream","offer","setLocalDescription","exception","console","error","initiateLocalStream","stream","navigator","mediaDevices","getUserMedia","video","audio","initiateConnection","configuration","iceServers","urls","conn","RTCPeerConnection","sendAudioStream","audioStream","websocket","audioContext","window","AudioContext","webkitAudioContext","recorder","MediaRecorder","mimeType","ondataavailable","event","audioBlob","data","reader","FileReader","readAsDataURL","onloadend","base64data","result","split","send","start","listenToConnectionEvents","remoteUsername","remoteVideoRef","doCandidate","onicecandidate","candidate","ontrack","e","srcObject","streams","sendAnswer","notif","doAnswer","JSON","parse","setRemoteDescription","answer","createAnswer","from","startCall","yourConn","addCandidate","addIceCandidate","RTCIceCandidate"],"sources":["/Users/rianadutta/Downloads/mchacks12/LiveTranslator/frontend3/reactReminder/src/modules/RTCModule.js"],"sourcesContent":["\nexport const createOffer = async (connection, localStream, userToCall, doOffer, database, username) => {\n  try {\n    connection.addStream(localStream)\n\n    const offer = await connection.createOffer()\n    await connection.setLocalDescription(offer)\n\n    doOffer(userToCall, offer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const initiateLocalStream = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    })\n    return stream\n  } catch (exception) {\n    console.error(exception)\n  }\n}\nexport const initiateConnection = async () => {\n  try {\n    // using Google public stun server\n    var configuration = {\n      iceServers: [{ urls: 'stun:stun2.1.google.com:19302' }]\n    }\n\n    const conn = new RTCPeerConnection(configuration)\n\n    return conn\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const sendAudioStream = async (audioStream, websocket) => {\n  const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n  const recorder = new MediaRecorder(audioStream, { mimeType: 'audio/webm' });\n\n  recorder.ondataavailable = async (event) => {\n    // Convert the audio blob to Base64\n    const audioBlob = event.data;\n    const reader = new FileReader();\n    reader.readAsDataURL(audioBlob);\n    reader.onloadend = () => {\n      const base64data = reader.result.split(',')[1]; // Strip the Base64 metadata prefix\n      websocket.send(base64data);\n    };\n  };\n\n  recorder.start(1000); // Send audio in 1-second chunks\n};\n\n\nexport const listenToConnectionEvents = (conn, username, remoteUsername, database, remoteVideoRef, doCandidate) => {\n  conn.onicecandidate = function (event) {\n    if (event.candidate) {\n      doCandidate(remoteUsername, event.candidate, database, username)\n    }\n  }\n\n  // when a remote user adds stream to the peer connection, we display it\n  conn.ontrack = function (e) {\n    if (remoteVideoRef.srcObject !== e.streams[0]) {\n      remoteVideoRef.srcObject = e.streams[0]\n    }\n  }\n}\n\nexport const sendAnswer = async (conn, localStream, notif, doAnswer, database, username) => {\n  try {\n    conn.addStream(localStream)\n\n    const offer = JSON.parse(notif.offer)\n    conn.setRemoteDescription(offer)\n\n    // create an answer to an offer\n    const answer = await conn.createAnswer()\n    conn.setLocalDescription(answer)\n\n    doAnswer(notif.from, answer, database, username)\n  } catch (exception) {\n    console.error(exception)\n  }\n}\n\nexport const startCall = (yourConn, notif) => {\n  const answer = JSON.parse(notif.answer)\n  yourConn.setRemoteDescription(answer)\n}\n\nexport const addCandidate = (yourConn, notif) => {\n  // apply the new received candidate to the connection\n  const candidate = JSON.parse(notif.candidate)\n  yourConn.addIceCandidate(new RTCIceCandidate(candidate))\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}